[{"title":"萬事起頭難","url":"/2024/03/03/%E8%90%AC%E4%BA%8B%E8%B5%B7%E9%A0%AD%E9%9B%A3/","content":"部落格的第一篇文章就以自我認知與成長為出發點，期待能啟發或幫助在職涯遇到阻礙的讀者。\n踏出舒適圈讀博士班期間參加了交大網路福利社、旁聽資工系所課程，才算接觸真正的軟體開發。跨領域從頭堆積這些基礎知識尤其辛苦，畢竟當年網際網路剛蓬勃發展，能獲取的知識都只能來自實體課程或者買本相關的書籍來參考實作。\n\n當時身為助教的我自學網頁程式設計(HTML、JavaScript、CSS)，再拜讀高中同學出版的書籍，在 Google App Engine 架了個教學網站，幫學生把教材變得更淺顯易懂，最後從學生的回饋中獲得滿滿成就感，讓我體會到「施比受更有福」的道理！\n\n\n\n初入戰場在第一份工作中什麼程式語言都要學(Java、C/C++、Python)，當時並沒有想那麼多，做就對了。不過內心總是有股力量驅使我定位自己，應該在某個領域做到專精，於是在審視自己一段時間後，決定了那個目標就是網頁前端。\n\n若工作中接觸很多很雜的事務，當下可能會抱怨，幾年後回過頭來想那卻是一種養分。例如，我在離職後找到網頁前端Angular的工作，便以為不會再接觸到Java，沒想到因為現在大環境變化，讓我需要靠曾經接觸過的技能來謀生活。\n\n堅定、深耕確定目標後，需要規劃適合自己的道路，並確實執行。在步入穩定之前分為兩個階段，其中執行力扮演極其重要的角色。\n\n起步\n了解自己現有的能力，選擇能達成目標所需的技能\n量身打造可行的小專案(side project)\n\n\n堅持\n把握下班與週末的有限時間，即使只有半小時也要妥善利用\n確實理解正在學習的技能，涉獵相關知識並記錄踩過的雷\n\n\n\n\n每個人的學習曲線都不同，每天能專心運用的時間可能也不多。有階段性成果時，不妨犒賞自己、適度休息，那都是很重要的動力來源。久而久之，這些努力都不會是一種負擔，反而成為一種習慣。\n\n穩定成長對於正在學習、成長的任何開發者，遇到的問題都可以在部落格、論壇或是 YouTube 影片中找到解答。真心感激前輩們的技術心得與經驗分享，這也是能成就現在的我的基石。\n\n雖然目前我身為社群組織的一員，會定期分享自己的技能，但也僅限於與會者。若我能把累積的知識也公開分享給任何想學習的人，這是一種取之於社會、用之於社會的回饋，如同剛才提到的「施比受更有福」。\n\n","categories":["有感而發"]},{"title":"Angular 新手村 - 0. 基礎知識","url":"/2024/03/12/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-0-%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/","content":"現在人們的生活已離不開網頁，上網這個行為充斥在各個層面的操作，有很大機會代表操作網頁，舉凡收發 E-mail、看 YouTube 影片、讀新聞等可以透過網頁完成。但這些服務並非只仰賴眼前看到的網頁畫面，甚至有更龐大、在幕後運作的系統，處理大量使用者的請求並回應資料。\n基本上，大致歸納上述＂在幕後運作的系統＂就是伺服器，也就是後端；＂網頁畫面＂則是前端。\n前端的網頁架構由於早期的網頁架構、功能簡單，沒有太多的畫面渲染需求，因此幾乎可以由一個人包辦前、後端的開發。隨著科技發達、技術演進，現在的網頁能做出任何想的到的畫面，當然架構也隨之龐大、複雜。若沒有前後端分離，光靠一個人會很難兼顧系統穩定與畫面流暢。\n\n前後端分離的好處是前、後端可以分別專注在實現自己的業務邏輯，降低耦合，兩者間藉由 HTTP&#x2F;HTTPS 或 WebSocket 進行溝通即可。\n\n\n\n想像一個場景：使用者在一個部落格的網頁中，選取文章A以進行閱讀的行為，如下圖所示。前端（粗框方塊）的任務看似不多，但顧及使用者體驗，就需要考量\n\n設計   進行切版、元件配色、動畫特效等，讓部落格吸引使用者想再次造訪。\n互動   接受使用者的要求，將後端所需資訊進行打包、透過網路送至後端。 \n反應   收到後端回應內容後，即時將其呈現在網頁，並優化在大量文章下的流暢性。\n\n\n註：虛線代表透過網際網路\n\n使用者體驗（user experience, UX）指的是使用者與產品、服務或系統互動時所產生的整體感受。\n\n三大主流\n\n\n前端框架／函式庫\n官網\n開發／維護者\n\n\n\nAngular\nhttps://angular.dev\nGoogle\n\n\nReact\nhttps://react.dev\nMeta\n\n\nVue\nhttps://vuejs.org\n個人開發者 尤雨溪（Evan You）\n\n\n截至 2024 年 Stack Overflow 詢問度趨勢， React （綠線）為大宗、 Angular （橘線）暫居第二：\n\n\n\n\n\n\n前端框架／函式庫\n特色\n應用領域\n\n\n\nAngular\n適用於大型應用程式和企業級開發，特別是需要結構化和可維護性的項目\n金融、醫療和大型商業應用\n\n\nReact\n採用組件化開發，提供靈活的開發方式，適合需要高互動性和動態內容的應用\n社交媒體、電子商務和內容管理系統\n\n\nVue\n使用簡潔的模板語法，學習曲線相對較低，適合快速開發和小型應用\n新創公司（特別是在需要快速迭代的環境）\n\n\n以上選擇因人而異，找出適合自己的來學即可。本系列以 Angular 為主題，後續章節會帶出由基礎到進階的相關知識。\n關於 Angular 框架\nAngular 是由 Google 團隊所開發的網頁開發框架，以 Node.js 進行套件管理、以 TypeScript 語言撰寫。Angular 提供簡潔、系統性、有規範的設計方式，打造出的適合於大型架構的單頁應用程式。\n\n框架（framework）是一種使用規範，它能保證按照它所訂定的規則來執行就會得到預期效果。因此框架能夠提供比函式庫更完整的功能與開發環境，達到較完整的解決方案。相反地，我們口語常說＂跳脫框架＂也就是不受到約束，可以隨心所欲按照自己的方式開發。\n\n\n單頁應用程式（Single Page Application, SPA）的特性是使用者與網頁的互動都在同一個網址，不會因轉址而刷新網頁造成畫面閃爍。\n\n版本匹配表Angular 的核心也是 Node.js 的套件（package），因此除了 TypeScript 以外，也需要相依 Node.js 的版本進行開發。而 RxJS 是 Angular 內部經常使用到的 reactive 函式庫（library）\n目前 Angular 支援的版本\n\n舊網站\n新網站（配合 Angular 17 推出）\n\n\n\n\nAngular\nNode.js\nTypeScript\nRxJS\n\n\n\n20.2.x\n^20.19.0 || ^22.12.0 || ^24.0.0\n&gt;&#x3D;5.9.0 &lt;6.0.0\n^6.5.3 || ^7.4.0\n\n\n20.0.x || 20.1.x\n^20.19.0 || ^22.12.0 || ^24.0.0\n&gt;&#x3D;5.8.0 &lt;5.9.0\n^6.5.3 || ^7.4.0\n\n\n19.2.x\n^18.19.1 || ^20.11.1 || ^22.0.0\n&gt;&#x3D;5.5.0 &lt;5.9.0\n^6.5.3 || ^7.4.0\n\n\n19.1.x\n^18.19.1 || ^20.11.1 || ^22.0.0\n&gt;&#x3D;5.5.0 &lt;5.8.0\n^6.5.3 || ^7.4.0\n\n\n19.0.x\n^18.19.1 || ^20.11.1 || ^22.0.0\n&gt;&#x3D;5.5.0 &lt;5.7.0\n^6.5.3 || ^7.4.0\n\n\n18.1.x || 18.2.x\n^18.19.1 || ^20.11.1 || ^22.0.0\n&gt;&#x3D;5.4.0 &lt;5.6.0\n^6.5.3 || ^7.4.0\n\n\n18.0.x\n^18.19.1 || ^20.11.1 || ^22.0.0\n&gt;&#x3D;5.4.0 &lt;5.5.0\n^6.5.3 || ^7.4.0\n\n\n\nAngular 9 後，不再長期支援的版本\n\n\n長期支援（long-term support, LTS）是指期間內會維持該版本的安全漏洞修復（fix）\n\n章節介紹新手村系列教學以 Angular 19 為基準，主要著重在建立下列基礎知識\n\nChapter 1 - 開發環境與操作指令（command line, CLI）\nChapter 2 - 元件（component）\nChapter 3 - 路由（routing）\nChapter 4 - 服務（service）\nChapter 5 - 指令（directive）\nChapter 6 - 管道（pipe）\nChapter 7 - 生命週期（life cycle）\nChapter 8 - 表單（form）\n\n官方網站\n舊網站\n英文版\n中文版\n\n\n新網站\n英文版\n中文版\n\n\n\n版本沿革\n\n\n年.月\n版本\n特色\n\n\n\n2010.10\nAngularJS (1.x)\n基於 JavaScript 的框架，為 MVC 架構\n\n\n2016.09\nAngularJS 2\n版本改以數字命名。基於 TypeScript 的框架，為元件（component）架構，且程式碼完全重寫，不能與 AngularJS 共用程式碼\n\n\n2017.03\nAngular 4\n在路由模組（routing module）出了版本對齊問題，決定放棄 Angular 3 、直奔 Angular 4 並引入 HttpClient\n\n\n2017.11\nAngular 5\n改進對漸進式網路應用程式（PWA）的支援\n\n\n2018.05\nAngular 6\n改進工具鏈（toolchain）\n\n\n2018.10\nAngular 7\n加強 Angular Material 和 CDK 功能\n\n\n2019.05\nAngular 8\n改進 Angular CLI\n\n\n2020.02\nAngular 9\n使用 Ivy 渲染引擎（redering engine）以降低捆綁檔案大小（bundle size）並增進效能\n\n\n2020.06\nAngular 10\n改進 Angular Material 、更新 TypeScript 語法\n\n\n2020.11\nAngular 11\n加強 Angular CLI 、更新 TypeScript 4.0\n\n\n2021.05\nAngular 12\n引入更嚴格的型別檢查、更新 Angular CLI\n\n\n2021.11\nAngular 13\n支援 TypeScript 4.4 、加強 Angular tests 、預設使用 RxJS 7.4\n\n\n2022.06\nAngular 14\n引入 standalone\n\n\n2022.11\nAngular 15\n預設使用 standalone 取代 NgModule\n\n\n2023.05\nAngular 16\n引入 Signal 提升效能、加強除錯能力，翻新 Angular Material\n\n\n2023.11\nAngular 17\n引入控制流程（control flow）語法、…等\n\n\n2024.05\nAngular 18\n穩定版的控制流程語法、實驗階段的 zoneless change detection\n\n\n2024.11\nAngular 19\n針對 Signal 加入反應式原語（Reactivity Primitives）、開發者預覽漸增式水合(hydration)\n\n\n\n註 1：每 6 個月釋出 1 個主版本\n\n\n註 2：主版本的支援週期為 18 個月\n\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 1. 開發環境與操作指令","url":"/2024/11/30/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-1-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E8%88%87%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/","content":"開發環境建置\n\n\n下載並安裝 Node.js 後，確認版本安裝完成  npm --version\n安裝 Angular CLI 來快速建構專案及其所需各種設定與元件  npm install -g @angular/cli  若要安裝特定版本（如 19.0.1），則使用  npm install -g @angular/cli@19.0.1\n\n參考官網：\n\nInstall the Angular CLI\n\n\n注意：\n\nWindows 預設使用 PowerShell 指令執行 npm 全域安裝，因此執行 npm install 前需要設定執行權限：Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned\n從 Angular 版本 7 開始，@angular&#x2F;core 和 CLI 的版本必須相同\n\n\n\n創建一個新專案，以聊天室專案為例  ng new chatroom\n\n\n過程中會詢問選擇何種樣式格式、是否啟用伺服器渲染等，先使用預設選項\n\n由於我們使用 Angular CLI 的指令建立專案，它會產生所有能讓應用程式首次啟動的檔案，同時建立 git 版控並幫你提交當前檔案！\n\n\n建立完畢，進入該專案目錄並啟動  cd chatroom  ng serve\n\n\n執行指令後，看到專案內的檔案最終被打包成數個檔案，提供給瀏覽器渲染在網頁上\n\n\n\n在瀏覽器輸入以下網址，可看見運行結果（確認專案建置成功）  http://localhost:4200\n\n\n\n專案設定確認專案正常運行後，我們要先了解以下專案的參數設定(configuration)檔，再進行開發（程式撰寫）：\n\npackage.json 包含我們所安裝的套件列表，包含\n@angular 為 Angular 官方套件\nrxjs 為響應式（reactive）開發套件\nzone.js 用來偵測應用程式的變更\n其他，如 tslib 、 karma 等\n\n\ntsconfig.json 為 TypeScript 的設定檔（編譯選項）\nangular.json 為 Angular 設定檔，包含環境參數、打包選項等\n\n例如，在 angular.json 的 projects.chatroom.architect.build 設定 production 的 budgets 參數，用來偵測並提示打包後的檔案大小，避免專案過於肥大造成瀏覽器載入畫面過慢。\n\"configurations\": &#123;\n  \"production\": &#123;\n    \"budgets\": [\n      &#123;\n        \"type\": \"initial\",\n        \"maximumWarning\": \"500kB\",\n        \"maximumError\": \"1MB\"\n      &#125;,\n      &#123;\n        \"type\": \"anyComponentStyle\",\n        \"maximumWarning\": \"4kB\",\n        \"maximumError\": \"8kB\"\n      &#125;\n    ],\n    \"outputHashing\": \"all\"\n  &#125;,\n  \"development\": &#123;\n    \"optimization\": false,\n    \"extractLicenses\": false,\n    \"sourceMap\": true,\n  &#125;\n&#125;,\n\n另外，也可自行新增 fileReplacements 參數與相關檔案至 development 參數中，方便在開發階段使用不同的環境設定檔。\n\"fileReplacements\": [\n  &#123;\n    \"replace\": \"src/environments/environment.ts\",\n    \"with\": \"src/environments/environment.development.ts\"\n  &#125;\n]\n\n\nfileReplacements 在 Angular CLI v15 後預設不再自動加入至 angular.json 檔\n\n開發工具選擇您喜歡的開發編輯器（IDE），如 Visual Studio Code 或 WebStorm 來開啟專案。這些工具能幫助進行型別檢查，減少開發時期的錯誤。\n下一篇，我們就可以直接使用開發編輯器來編輯第一個元件。\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 2. 元件","url":"/2024/12/07/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-2-%E5%85%83%E4%BB%B6/","content":"延續上一篇，我們完成以 Angular CLI 建立了聊天室專案 chatroom ，並認識一些環境參數與設定選項。\n元件（component）本篇首先認識集合呈現與行為的元件，它是由 CLI 所建立最頂層的元件，位於 src/app/ ，基本上由 4 支檔案所組成：\n\napp.component.html 提供網頁元素\napp.component.css 提供樣式\napp.component.ts 提供參數與運作功能\napp.component.spec.ts 提供單元測試\n\n對照到一個基本的網頁組成，就不難理解上述檔案的用途。\n\nHTML （附檔名 .html）\nCSS （附檔名 .css 、 .scss 、 …）\nJavaScript （附檔名 .js）\n\n讓我們先介紹差異最大的部分： app.component.ts\nimport &#123; Component &#125; from '@angular/core';\n\n@Component(&#123;\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n&#125;)\nexport class AppComponent &#123;\n  title = 'chatroom';\n&#125;\n\n讓我們來解析這支程式：\n\n第 1 行由 @angular/core 引入程式所需要的 @Component 裝飾子\n第 3 行在類別（class）前加註 @Component 裝飾子，即告訴 Angular 這個類別被視為元件\n第 4 ～ 6 行為 @Component 裝飾子的內容，稱為此元件的 metadata （元資料或中繼資料）\nselector 參數最重要，它會告訴 Angular 要在網頁中尋找的名稱，每個名稱在專案內都是唯一的。例如，若網頁中包含 &lt;app-root&gt;&lt;/app-root&gt; 區塊， Angular 會找出元件類別並實體化它。\ntemplateUrl 參數用來指示 HTML 檔的路徑。可換成 template 參數，直接接受 HTML 語法\nstyleUrl 參數用來指示樣式檔（ CSS 或 SCSS ）的路徑。可換成 styles 參數，直接接受樣式語法 \n在早期的版本，可能會看到 standalone 參數，代表此元件是否支援直接由別的元件引入，而不需要 Angular module 。\nstandalone 歷程：\n\nAngular 15 提出\nAngular 17 預設加入 standalone: true （在此之前，元件都必須宣告在 Angular module ）\nAngular 19 即使不加 standalone: true 選項，已預設為 standalone\n\n\n\n\n\n第 8 ～ 10 行為元件類別的內部資料與函式。\n\n在以下的 app.component.html 中加入以下語法後，在 ng serve 的運作下，就能在瀏覽器看到所呈現的畫面。\n&lt;h1>Hello, &#123;&#123; title &#125;&#125;&lt;/h1>\n&lt;p>恭喜！您的應用程式正常運行著！&lt;/p>\n\n\n此處的 &#123;&#123; title &#125;&#125; 是為範本插值（ template interpolation ），為 app.component.ts 提供資料給 app.component.html 呈現的方式之一，亦即 &#123;&#123; title &#125;&#125; 會被它本身的值（ chatroom ）替換掉。\n\n\n\n\n\n即使已看到初步成果，但好奇的我們仍會想了解整個專案的運作流程。\n首先，回想上一篇所提到的 Angular 設定檔 angular.json ，在 projects.chatroom.architect.build.options 中定義了專案的進入點與其樣式：\n\"options\": &#123;\n  // ...\n  \"index\": \"src/index.html\",\n  \"browser\": \"src/main.ts\",\n  \"styles\": [\n    \"src/styles.css\"\n  ],\n  // ...\n&#125;,\n\n我們回頭看 main.ts 呼叫 bootstrapApplication 函式，並指定 AppComponent 成為應用程式的根元件（root component）。\nimport &#123; bootstrapApplication &#125; from '@angular/platform-browser';\nimport &#123; appConfig &#125; from './app/app.config';\nimport &#123; AppComponent &#125; from './app/app.component';\n\nbootstrapApplication(AppComponent, appConfig)\n  .catch((err) => console.error(err));\n\n再來看最重要的 index.html ，即使 Angular CLI 建立的 index.html 內部並沒有任何 JavaScript 檔，但在 body 中包含了 &lt;app-root&gt;&lt;/app-root&gt; 區塊。因此在 ng serve 時， TypeScript 編譯器會產出 JavaScript 檔，並交由 Angular CLI 打包後加入至 index.html 檔。這些過程 Angular 都會自動處理完成，因此我們可以專注在程式功能的開發。\n&lt;!doctype html>\n&lt;html lang=\"en\">\n&lt;head>\n  &lt;meta charset=\"utf-8\">\n  &lt;title>Chatroom&lt;/title>\n  &lt;base href=\"/\">\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n&lt;/head>\n&lt;body>\n  &lt;app-root>&lt;/app-root>\n&lt;/body>\n&lt;/html>\n\n總結上述步驟， Angular 運作流程可以下圖表示：\n---\ntitle: \n---\nflowchart LR\n  subgraph angular[Angular]\n    a(\"angular.json\") --> m(\"src/main.ts\") -- bootstrap --> c(\"src/app/app.component\") -- build --> buildTool\n    subgraph buildTool[Javascript build tool]\n      compiler[\"TypeScript compiler\"] --> vite[\"Vite\"]\n    end\n  end\n\n  buildTool -- package --> browser\n\n  subgraph browser[Browser]\n    index(\"index.html\")\n  end\n\n\n回到元件的運作，目前已知能使用範本插值將 app.component.ts 內的資料呈現在 app.component.html 。在 Angular 17 版後可以使用較新的寫法，由 @angular/core 引入 signal() 函式，在 Angular 設定變更偵測（ change detection ）為 OnPush 時，讓 Angular 將 signal 視為元件的相依變數，若其值有變化，會自動被標註（mark）進行渲染更新。\napp.component.html 與 app.component.ts 分別可以改寫為\n&lt;h1>Hello, &#123;&#123; title() &#125;&#125;&lt;/h1>\n&lt;p>恭喜！您的應用程式正常運行著！&lt;/p>\nimport &#123; Component, signal &#125; from '@angular/core';\n\n@Component(&#123;\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.css'\n&#125;)\nexport class AppComponent &#123;\n  title = signal('chatroom');\n&#125;\n\n\nsignal() 歷程：\n\nAngular 16 提出開發者預覽版\nAngular 17 成為穩定版\n\n\n參考官網：\n\nAngular Signals\n\n\n隨著專案未來可能越來越龐大，不可能將所有的功能、樣式都集中在根元件 AppComponent ，因此我們需要設計更多元件以實現不同的商業邏輯（business logic），這個時候就能使用 Angular CLI 的 ng generate component &lt;component-name&gt; 或 ng g c &lt;component-name&gt; 來建立新的元件。\n想定一個聊天室應該會有的使用情境：\n\n進入大廳（hall），顯示多個聊天室入口\n點選某個聊天室入口進入聊天室視窗（chatroom）\n在聊天室視窗中，有訊息串與輸入框，經由發送（Send）按鈕可將所輸入的訊息加入至訊息串\n在聊天室視窗中，有返回按鈕可回到大廳\n建立新聊天室\n\n\n\n對上述需求進行分析後，我們可以勾勒出基本架構與相關元件：\n\n\n按以下步驟使用 Angular CLI 即可迅速建立所有檔案\n\n在 src/app/ 建立 pages 資料夾，並在內部建立 pages 元件：  ng g c pages\n接著在 pages 資料夾內部建立 chatroom 與 hall 兩個資料夾與其元件：  ng g c pages/chatroom  ng g c pages/hall\n接著在 chatroom 資料夾內部建立 components 資料夾，內部包含 messages 與 message-input 兩個資料夾與其元件：  ng g c pages/chatroom/components/messages  ng g c pages/chatroom/components/message-input\n\n最終在 src/app/ 成功建立所需元件。\n\n\n下一章，我們會介紹如何將以上所建立的元件組合在一起。\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 3. 路由","url":"/2024/12/29/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-3-%E8%B7%AF%E7%94%B1/","content":"延續上一篇，我們以 Angular CLI 建立了聊天室專案 chatroom 所有的元件，接下來介紹如何將它們組合在一起。\n路由（Routing）若要將元件組合在一起，只需要放置元件的標籤（ tag ）在適合的位置即可，例如：\n\n把 hall 與 chatroom 元件放置在 pages 元件中，在 pages.component.html 加入元件的 CSS selector&lt;app-hall>&lt;/app-hall>\n&lt;app-chatroom>&lt;/app-chatroom>\n同時，加入元件實體至 pages.component.ts 的 metadata@Component(&#123;\n  selector: 'app-pages',\n  imports: [HallComponent, ChatroomComponent], // ←\n  templateUrl: './pages.component.html',\n  styleUrl: './pages.component.css'\n&#125;)\n把 messages 與 message-input 元件放置在 chatroom 元件中，在 chatroom.component.html 加入元件的 CSS selector&lt;app-messages>&lt;/app-messages>\n&lt;app-message-input>&lt;/app-message-input>\n同時，加入元件實體至 chatroom.component.ts 的 metadata@Component(&#123;\n  selector: 'app-chatroom',\n  imports: [MessagesComponent, MessageInputComponent], // ←\n  templateUrl: './chatroom.component.html',\n  styleUrl: './chatroom.component.css'\n&#125;)\n\n我們可以看到除了 pages 與 chatroom 以外的元件都顯示各自的初始文字，這是因為在 pages 與 chatroom 的內部元素已其他元件置換掉。\n\n\n但是，這樣的呈現方式並不是我們想要的畫面。我們想要的是讓使用者能在 hall 與 chatroom 之間切換顯示，這個部分可以使用路由達到這樣的效果。除此之外，使用路由的好處在於：\n\n套用守衛（guard）根據訂製的規則來限制或允許路由導引\n套用解析器（resolver）來處理或加工路由間傳遞的資料\n在不同的路由共享共通範本（template）\n\n我們在 hall 與 chatroom 的上一層 pages 資料夾內建立路由檔 pages.routes.ts ，內容如下：\nimport &#123; Routes &#125; from '@angular/router';\n\nexport const PAGES_ROUTES: Routes = [\n  &#123;\n    path: '',\n    redirectTo: 'hall',\n    pathMatch: 'full'\n  &#125;,\n  &#123;\n    path: 'hall',\n    loadComponent: () => import('./hall/hall.component').then(m => m.HallComponent)  \n  &#125;,\n  &#123;\n    path: 'chatroom',\n    loadComponent: () => import('./chatroom/chatroom.component').then(m => m.ChatroomComponent)  \n  &#125;,\n  &#123;\n    path: '**',\n    redirectTo: 'hall'\n  &#125;\n];\n\n這個路由檔分成四個由 &#123; 與 &#125; 括起來的路由：\n\n第一項（4 ~ 8 行）：若沒有給定路徑（空字串），則導到 hall 路徑\n第二項（9 ~ 12 行）：在 hall 路徑下會顯示 HallComponent 內容\n第三項（13 ~ 16 行）：在 chatroom 路徑下會顯示 ChatroomComponent 內容\n第四項（17 ~ 20 行）：給定任何路徑都會導到 hall 路徑\n\n\n\npath 為網址會驅動而進行導引的路徑。\n這些路由有其順序性（由上而下），若第四項移到第一項，造成給定 chatroom 路徑也會導到 hall 路徑的不預期後果。\n第 11 與 15 行的 loadComponent 提供 Lazy-loading 的效果。\n\n\n接著在應用程式的路由檔 app.routes.ts 匯入 pages.routes.ts：\nexport const routes: Routes = [\n  &#123;\n    path: '',\n    loadChildren: () => import('./pages/pages.routes').then(m => m.PAGES_ROUTES)\n  &#125;\n];\n\n雖然我們已建立路由，但當導到某個元件時，它應該在何處顯示，此時就需要在上層元件加入一個特殊的標籤 &lt;router-outlet&gt; ，用來乘載由路由導到的元件。因此元件架構中的 app-hall 與 app-chatroom 可以被 &lt;router-outlet&gt; 取代掉，如下圖所示。\n\n\n\n\n實作步驟如下：\n\n確認在 app.config.ts 中，已經啟用路由功能並加入路由檔。\n  import &#123; ApplicationConfig &#125; from '@angular/core';\nimport &#123; provideRouter &#125; from '@angular/router'; // ←\nimport &#123; routes &#125; from './app.routes'; // ←\n\nexport const appConfig: ApplicationConfig = &#123;\n  providers: [\n    provideRouter(routes) // ←\n  ]\n&#125;;\n\n在 pages.component.ts 將 RouterOutlet 匯入。\n  import &#123; Component &#125; from '@angular/core';\nimport &#123; RouterOutlet &#125; from '@angular/router';\n\n@Component(&#123;\n  selector: 'app-pages',\n  imports: [RouterOutlet], // ←\n  templateUrl: './pages.component.html',\n  styleUrl: './pages.component.css'\n&#125;)\nexport class PagesComponent &#123; &#125;\n\n在 pages.component.html 直接將 hall 與 chatroom 元件都移除，只留下 &lt;router-outlet&gt; 。\n  &lt;router-outlet>&lt;/router-outlet>\n\n我們在瀏覽器輸入一樣的 http://localhost:4200 網址時，看到路徑會導到 http://localhost:4200/hall 並呈現大廳（hall）的畫面（如下圖左）；手動改變網址 http://localhost:4200/chatroom 則會呈現聊天室視窗（chatroom）的畫面（如下圖右）。\n\n\n由於目前兩個元件都顯得單調，讓我們稍微點綴它們吧！\n\n分別在 hall.component.html 與 hall.component.css 加入以下元素與樣式：\n&lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-direction: column; flex-grow: 1; align-items: center; justify-content: center; border: 1px solid black;\">\n    chatrooms will be shown here\n  &lt;/div>\n  &lt;div style=\"margin: 1rem; display: flex; justify-content: center;\">\n    &lt;button type=\"button\">Create a new one&lt;/button>\n  &lt;/div>\n&lt;/div>\n:host &#123;\n  display: block;\n  width: 100%;\n  height: 100%;\n&#125;\n\n分別在 chatroom.component.html 與 chatroom.component.css 加入以下元素與樣式：\n&lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n  &lt;div style=\"margin: 1rem; display: flex; justify-content: space-between;\">\n    &lt;div>chatroom name will be shown here&lt;/div>\n    &lt;button type=\"button\">Back to hall&lt;/button>\n  &lt;/div>\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; align-items: center; justify-content: center; border: 1px solid black;\">\n    &lt;app-messages>&lt;/app-messages>\n  &lt;/div>\n  &lt;div style=\"height: 4rem; margin: 1rem; display: flex; gap: 1rem; align-items: stretch;\">\n    &lt;div style=\"flex-grow: 1;\">\n      &lt;app-message-input>&lt;/app-message-input>\n    &lt;/div>\n    &lt;div style=\"display: flex; align-items: center;\">\n      &lt;button type=\"button\" style=\"height: 100%;\">Send&lt;/button>\n    &lt;/div>\n  &lt;/div>\n&lt;/div>\n:host &#123;\n  display: block;\n  width: 100%;\n  height: 100%;\n&#125;\n\n分別在 messages.component.html 與 message-input.component.html 加入以下元素：\n&lt;div>messages will be shown here&lt;/div>\n&lt;textarea style=\"display: block; width: 100%; height: 100%; padding: 0; border: none; outline: 1px solid black; resize: none;\" placeholder=\"say something here\">&lt;/textarea>\n\n將以下全域樣式加入至 src 資料夾下的 style.css 檔：\nhtml, body &#123;\n  width: 100lvw;\n  height: 100lvh;\n  margin: 0;\n  padding: 0;\n&#125;\n\nbody &#123;\n  font-family: Roboto, \"Helvetica Neue\", sans-serif;\n&#125;\n\n重新在瀏覽器輸入 http://localhost:4200/hall 與 http://localhost:4200/chatroom ，能看見排版後的效果。\n\n\n即使兩個元件都能在各自網址中呈現，但這並不是我們要的結果。我們可以加入導引（navigation）機制，讓使用者經由互動來切換它們，而非手動改變網址。在此，我們先針對 chatroom 加入返回 hall 的功能：\n\n在按鈕點擊後會呼叫 backToHall() 函式\n  &lt;button type=\"button\" (click)=\"backToHall()\">Back to hall&lt;/button>\n\n在 chatroom.component.ts 中注入 Router 服務，並使用它進行網址導引\n  // 略\nexport class ChatroomComponent &#123;\n  private readonly router = inject(Router);\n\n  backToHall() &#123;\n    this.router.navigate(['/hall']);\n  &#125;\n&#125;\n\n試著點擊”Back to hall”按鈕，它會預期地將網址導引至 http://localhost:4200/hall 。\n接著，針對由 hall 進入 chatroom 加入路由：\n\n在 hall.component.ts 建立聊天室物件，並在 hall.component.html 顯示其路由連結。  import &#123; Component &#125; from '@angular/core';\nimport &#123; RouterLink &#125; from '@angular/router';\n\n@Component(&#123;\n  selector: 'app-hall',\n  imports: [RouterLink],\n  templateUrl: './hall.component.html',\n  styleUrl: './hall.component.css'\n&#125;)\nexport class HallComponent &#123;\n  mockChatroom: &#123; id: number, name: string &#125; = &#123;\n    id: 1,\n    name: 'Chatroom A'\n  &#125;;\n&#125;\n  &lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-direction: column; flex-grow: 1; justify-content: start; border: 1px solid black;\">\n    &lt;a [routerLink]=\"['/chatroom', mockChatroom.id]\">\n      &lt;div style=\"margin: 2px 0; padding: 4px; border: 1px solid blue; border-radius: 4px;\">\n        &#123;&#123; mockChatroom.name &#125;&#125;\n      &lt;/div>\n    &lt;/a>\n  &lt;/div>\n  &lt;div style=\"margin: 1rem; display: flex; justify-content: center;\">\n    &lt;button type=\"button\">Create a new one&lt;/button>\n  &lt;/div>\n&lt;/div>\n  解析上述行為：\n\n\n匯入 RouterLink 讓我們能在範本使用 routerLink 。\n以超連結 &lt;a [routerLink]=&quot;[&#39;/chatroom&#39;, mockChatroom.id]&quot;&gt; 讀取特定路徑（串接 /chatroom 與 id ）。\n當使用者點選連結時，根據特定路徑導引至該聊天室。\n\n\n我們不使用傳統超連結（如 &lt;a href=&quot;…&quot;&gt;&lt;/a&gt; ）來進行網址導引，因為它會讓瀏覽器重新載入該網址並重啟整個應用程式，此舉違反單頁應用程式（Single Page Application, SPA）欲達到的效果。\n\n\n在 pages.routes.ts 僅修改第 14 行的聊天室路由。\n  import &#123; Routes &#125; from '@angular/router';\n\nexport const PAGES_ROUTES: Routes = [\n  &#123;\n    path: '',\n    redirectTo: 'hall',\n    pathMatch: 'full'\n  &#125;,\n  &#123;\n    path: 'hall',\n    loadComponent: () => import('./hall/hall.component').then(m => m.HallComponent)  \n  &#125;,\n  &#123;\n    path: 'chatroom/:id', // ←\n    loadComponent: () => import('./chatroom/chatroom.component').then(m => m.ChatroomComponent)  \n  &#125;,\n  &#123;\n    path: '**',\n    redirectTo: 'hall'\n  &#125;\n];\n\n添加基於 signal 的輸入（ input ） 至 chatroom.component.ts ，並修改 chatroom.component.html 第 3 行以顯示 id 值：\n  // 略\nexport class ChatroomComponent &#123;\n  id = input.required&lt;string>();\n  // 略\n&#125;\n  &lt;!-- 略 -->\n&lt;div>&#123;&#123; id() &#125;&#125;&lt;/div>\n&lt;!-- 略 -->\n\n參考：\n\n簡化 Angular 16 路由機制：使用 @Input() 取得路由參數值\n\n如此一來，不管在 http://localhost:4200/hall 或 http://localhost:4200/chatroom ，都能經由點擊畫面按鈕進行切換。\n\n\n下一章，我們會以服務建立並提供更多測試資料，讓應用程式更加豐富。\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 4. 服務","url":"/2025/01/06/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-4-%E6%9C%8D%E5%8B%99/","content":"延續上一篇，我們已經在 hall 建立一個聊天室物件 mockChatroom ，並在 hall.component.html 顯示其路由連結，點擊該聊天室則導引到相關頁面。實際上大廳會存在許多聊天室物件，在介紹服務（service）之前，先嘗試在 hall 建立更多測試資料，確保聊天室顯示與連結均正常：\n\n在 src/app 下手動新增 models 資料夾並在內部新增檔案 chatroom.model.ts ，這個介面後續將會頻繁使用。  \n  定義 ChatroomModel 介面需要的屬性與型態：  export interface ChatroomModel &#123;\n  id: number;\n  name: string;\n&#125;\n\n\n建立聊天室物件介面的目的是管理或取得聊天室物件時，能依循我們所規範的結構（編輯器也會在我們錯誤操作物件屬性時提示錯誤）。\n\n\n在 hall.component.ts 加入多筆測試資料，並將其依序顯示在 hall.component.html 中。  import &#123; Component, signal &#125; from '@angular/core';\nimport &#123; RouterLink &#125; from '@angular/router';\nimport &#123; ChatroomModel &#125; from '../../models/chatroom.model';\n\n@Component(&#123;\n  selector: 'app-hall',\n  imports: [RouterLink],\n  templateUrl: './hall.component.html',\n  styleUrl: './hall.component.css'\n&#125;)\nexport class HallComponent &#123;\n  chatrooms = signal&lt;Array&lt;ChatroomModel>>([\n    &#123; id: 1, name: 'Chatroom A' &#125;,\n    &#123; id: 2, name: 'Chatroom B' &#125;\n  ]);\n&#125;\n\n\n第 3 行將我們所定義的 ChatroomModel 介面引入。\n第 12 ~ 15 行將兩個測試的聊天室物件以陣列的方式，提供給 chatrooms ，在 signal 角括號內的 Array&lt;ChatroomModel&gt; 表示它僅接受滿足 ChatroomModel 這個介面組成的陣列。  &lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-direction: column; flex-grow: 1; justify-content: start; border: 1px solid black; overflow-y: auto;\">\n    @for (chatroom of chatrooms(); track chatroom.id) &#123;\n      &lt;a [routerLink]=\"['/chatroom', chatroom.id]\">\n        &lt;div style=\"margin: 2px 0; padding: 4px; border: 1px solid blue; border-radius: 4px;\">\n          &#123;&#123; chatroom.name &#125;&#125;\n        &lt;/div>\n      &lt;/a>\n    &#125; @empty &#123;\n      &lt;div>No chatrooms&lt;/div>\n    &#125;\n  &lt;/div>\n  &lt;div style=\"margin: 1rem; display: flex; justify-content: center;\">\n    &lt;button type=\"button\">Create a new one&lt;/button>\n  &lt;/div>\n&lt;/div>\n第 3 行的 @for 是一種控制流語法（control flow syntax），用來遍歷陣列並依序取出項目。該行的意思為依序取出在 chatrooms() 內的 chatroom 項目並以 chatroom.id 當作追蹤每個項目的唯一識別子，這是 Angular 用來提升效能的方式。每當陣列中某個項目有變動時，因為有識別子，僅需要更新該物件即可，而非整個陣列。\n第 4 ~ 8 行大括號內則是用來呈現每個 chatroom 項目，我們建立路由與每個路由顯示各自的 chatroom.name ，經由點擊導引到不同的聊天室頁面。\n第 9 ~ 10 行的 @empty 會在 chatrooms() 為空（或 null 或 undefined ）時顯示 No chatrooms 字樣，而不會在此區塊中留白。\n\n\n控制流語法（control flow syntax）：\n\nAngular 17 開始提供\nAngular 18 成為內建語法\n使用 ng g @angular/core:control-flow 可將專案內所有已存在的結構型指令（structural directive）如 ngIf 與 ngFor 轉換成控制流語法。\n\n\n\n\n雖然目前大致上完成基本功能，不過我們發現 chatrooms 這個聊天室物件陣列並無法共享給其他元件使用，並且在元件中管理並操作這些資料並不是良好的設計，而是應該有一個專門集中管理這些資料的地方，並提供操作的方式給任何需要使用的元件。將來在佈署應用程式時，服務的另一個重要功能就是用來與後端進行溝通。因此資料獲取、儲存、操作等功能，就是服務提供的優勢。將這些功能由元件中抽離出來，也能讓程式碼更簡潔、易維護。\n使用 Angular CLI 即可建立一個服務，例如想要在既有的 src/app 下新增一個資料夾 services 並在其中建立服務 ChatroomService ，使用 ng generate service services/chatroom 或 ng g s services/chatroom 即可完成檔案建置。接著進行以下步驟：\n\n把需要共享的聊天室物件陣列搬移至 chatroom.service.ts （這個檔案即為 ChatroomService 服務）。  import &#123; Injectable, signal &#125; from '@angular/core';\nimport &#123; ChatroomModel &#125; from '../models/chatroom.model';\n\n@Injectable(&#123;\n  providedIn: 'root'\n&#125;)\nexport class ChatroomService &#123;\n  chatrooms = signal&lt;Array&lt;ChatroomModel>>([\n    &#123; id: 1, name: 'Chatroom A' &#125;,\n    &#123; id: 2, name: 'Chatroom B' &#125;\n  ]);\n\n  getChatrooms() &#123;\n    return this.chatrooms;\n  &#125;\n\n  addChatroom(name: string) &#123;\n    this.chatrooms.update(chatrooms => [...chatrooms, &#123; id: chatrooms.length + 1, name &#125;]);\n  &#125;\n&#125;\n  解析上述服務程式碼：\n\n\n第 4 ~ 6 行的裝飾子 @Injectable() 代表其為可注入的服務，而內部參數 providedIn: &#39;root&#39; 代表其層級為根注入器（或在 app.config.ts 中將 ChatroomService 加入至 providers 陣列）\n第 8 ~ 11 行僅將原本 hall.component.ts 內的聊天室物件陣列搬移至此\n第 13 ~ 15 行的 getChatrooms 函式用來提供聊天室物件陣列 chatrooms\n第 17 ~ 19 行的 addChatroom 函式用來新增聊天室物件至陣列 chatrooms\n\n\n在 hall 中注入（inject）此服務。  import &#123; Component, inject, Signal &#125; from '@angular/core';\nimport &#123; RouterLink &#125; from '@angular/router';\nimport &#123; ChatroomService &#125; from '../../services/chatroom.service';\nimport &#123; ChatroomModel &#125; from '../../models/chatroom.model';\n\n@Component(&#123;\n  selector: 'app-hall',\n  imports: [RouterLink],\n  templateUrl: './hall.component.html',\n  styleUrl: './hall.component.css'\n&#125;)\nexport class HallComponent &#123;\n  private chatroomService = inject(ChatroomService);\n  chatrooms: Signal&lt;Array&lt;ChatroomModel>> = this.chatroomService.getChatrooms();\n\n  addChatroom() &#123;\n    const chatroomName = prompt('Enter chatroom name');\n    if (!chatroomName) return;\n    this.chatroomService.addChatroom(chatroomName);\n  &#125;\n&#125;\n  解析上述元件程式碼：\n\n\n第 13 行將 ChatroomService 服務注入至元件，以便呼叫它的函式\n第 14 行的 chatrooms 改為由已注入的 ChatroomService 服務提供的 getChatrooms() 來獲得\n第 16 ~ 20 行建立測試函式，以簡易的彈出視窗讓使用者輸入聊天室名稱後，呼叫 ChatroomService 服務提供的 addChatroom() 來新增一個聊天室物件\n\n\ninject()：\n\nAngular 14 開始提供\n用來告訴 Angular 取得並返回 ChatroomService 服務\n在此之前，注入依賴（dependency）唯一的方式是在建構子（constructor）內宣告，例如第 13 行的寫法可以換作 constructor(private chatroomService: ChatroomService) &#123;&#125;\n\n\n\n將新增按鈕的點擊功能加入至 hall.component.html 。  &lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-direction: column; flex-grow: 1; justify-content: start; border: 1px solid black; overflow-y: auto;\">\n    @for(chatroom of chatrooms(); track chatroom.id) &#123;\n      &lt;a [routerLink]=\"['/chatroom', chatroom.id]\">\n        &lt;div style=\"margin: 2px 0; padding: 4px; border: 1px solid blue; border-radius: 4px;\">\n          &#123;&#123; chatroom.name &#125;&#125;\n        &lt;/div>\n      &lt;/a>\n    &#125; @empty &#123;\n      &lt;div>No chatrooms&lt;/div>\n    &#125;\n  &lt;/div>\n  &lt;div style=\"margin: 1rem; display: flex; justify-content: center;\">\n    &lt;button type=\"button\" (click)=\"addChatroom()\">Create a new one&lt;/button>\n  &lt;/div>\n&lt;/div>\n\n\n第 14 行將按鈕加入 click 點擊事件時，觸發呼叫 addChatroom() 函式\n\n總結如下：\n\n將 ChatroomService 注入至 HallComponent\n在 hall.component.ts 使用 ChatroomService 所提供的 getChatrooms() 與 addChatroom(name: string)  a. 使用 getChatrooms() 獲得所有的聊天室陣列，賦值給 signal chatrooms 供 hall.component.html 顯示  b. 建立 addChatroom() 接收來自按鈕觸發並接收使用者賦予的聊天室名稱後，呼叫 addChatroom(name: string) 來新增一個聊天室\n以 @for 列出 chatrooms() 內的所有聊天室，並設定按鈕點擊來觸發 addChatroom()\n\n\n\n經由改寫後，雖然經由瀏覽器看到的結果並無變化，但底層的程式架構已變得易維護。元件由服務取得資料並呈現出來，以及接收使用者的動作並傳送至服務；服務則掌管資料的建立與處理，如此一來分工明確、權責劃分清楚，在多人維護的專案下開發效率佳也不容易出錯。\n最後，繼續將 ChatroomService 擴充功能至 chatroom 元件。\n\n建立 MessageModel 介面，並在 ChatroomModel 中新增 MessageModel 陣列型態的 messages 屬性。export interface MessageModel &#123;\n  timestamp: string;\n  name: string;\n  content: string;\n&#125;;\n\nexport interface ChatroomModel &#123;\n  id: number;\n  name: string;\n  messages: MessageModel[];\n&#125;\n\n\nMessageModel 介面的組成為\ntimestamp 時間戳記：當一筆訊息被建立時，會同時產生時間字串。我們可以視它為訊息的 id （唯一識別碼）\nname 發送者名稱：賦予該訊息由哪個使用者發送\ncontent 訊息內容：儲存該訊息的內容字串\n\n\nChatroomModel 額外加入的 messages 屬性用來儲存該聊天室所有的訊息\n\n\n由於 messages 屬性已添加至 ChatroomModel ，因此修改 chatroom.service.ts 內的測試用聊天室物件陣列 chatrooms 並加入聊天室及訊息的相關函式。  // 略\nchatrooms = signal&lt;Array&lt;ChatroomModel>>([\n  &#123; id: 1, name: 'Chatroom A', messages: [\n    &#123; timestamp: '2021-01-01 00:00:00', name: 'Alice', content: 'Hello, World!' &#125;,\n    &#123; timestamp: '2021-01-01 00:00:01', name: 'Bob', content: 'Hi, Alice!' &#125;,\n  ] &#125;,\n  &#123; id: 2, name: 'Chatroom B', messages: [] &#125;,\n]);\n\ngetChatrooms() &#123;\n  return this.chatrooms;\n&#125;\n\ngetChatroom(chatroomId: number) &#123;\n  return this.chatrooms().find(chatroom => chatroom.id === chatroomId);\n&#125;\n\naddChatroom(name: string) &#123;\n  this.chatrooms.update(chatrooms => [...chatrooms, &#123; id: chatrooms.length + 1, name, messages: [] &#125;]);\n&#125;\n\ngetMessages(chatroomId: number) &#123;\n  return this.chatrooms().find(chatroom => chatroom.id === chatroomId)?.messages;\n&#125;\n\nsendMessage(chatroomId: number, name: string, content: string) &#123;\n  this.chatrooms.update(chatrooms => chatrooms.map(chatroom => &#123;\n    return chatroom.id === chatroomId ?\n      &#123; ...chatroom, messages: [...chatroom.messages, &#123; timestamp: new Date().toISOString(), name, content &#125;] &#125; :\n      chatroom;\n  &#125;));\n&#125;\n\n\n第 10 ~ 20 行為 chatroom 相關函式\ngetChatrooms() 獲得所有的聊天室陣列，賦值給 signal chatrooms\ngetChatroom(chatroomId: number) 接受聊天室的 id ，返回該聊天室物件\naddChatroom(name: string) 接受聊天室的 name ，建立聊天室物件（賦予 id ）並添加至 chatrooms\n\n\n第 22 ~ 31 行為 message 相關函式\ngetMessages(chatroomId: number) 接受聊天室的 id ，返回該聊天室物件內的訊息陣列\nsendMessage(chatroomId: number, name: string, content: string) 接受聊天室的 id 、 name 與 content ，建立訊息物件並添加至該聊天室的 messages\n\n\n\n\n建立 message.service.ts 並在其中注入 ChatroomService 以使用其函式。  import &#123; inject, Injectable &#125; from '@angular/core';\nimport &#123; ChatroomService &#125; from './chatroom.service';\n\n@Injectable(&#123;\n  providedIn: 'root'\n&#125;)\nexport class MessageService &#123;\n  chatroomService = inject(ChatroomService);\n\n  getMessages(chatroomId: number) &#123;\n    return this.chatroomService.getMessages(chatroomId) || [];\n  &#125;\n\n  sendMessage(chatroomId: number, name: string, content: string) &#123;\n    this.chatroomService.sendMessage(chatroomId, name, content);\n  &#125;\n&#125;\n\n\n第 10 ~ 12 行的 getMessages(chatroomId: number) 用來呼叫 ChatroomService 的函式，獲得該聊天室的訊息陣列\n第 14 ~ 16 行的 sendMessage(chatroomId: number, name: string, content: string) 接受聊天室的 id 、 name 與 content ，用來呼叫 ChatroomService 的函式，添加訊息至該聊天室的 messages\n\n\n在 chatroom.component.ts 中加入  // 略\nprivate readonly chatroomService = inject(ChatroomService);\nchatroom = computed(() => &#123;\n  const id = Number(this.id());\n  return this.chatroomService.getChatroom(id);\n&#125;);\n\nprivate readonly messageService = inject(MessageService);\nmessages = computed(() => &#123;\n  const id = Number(this.id());\n  return this.messageService.getMessages(id);\n&#125;);\n\n\n第 2 ~ 6 行注入 ChatroomService ，以 signal id 建立聊天室物件 signal chatroom\n第 8 ~ 12 行注入 MessageService ，以 signal id 建立聊天室訊息陣列 signal messages\n\n\n改動主要在於 chatroom.component.html 的訊息顯示部分。  &lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n  &lt;div style=\"margin: 1rem; display: flex; justify-content: space-between;\">\n    &lt;div style=\"font-size: large; font-weight: bold;\">&#123;&#123; chatroom()?.name &#125;&#125;&lt;/div>\n    &lt;button type=\"button\" (click)=\"backToHall()\">Back to hall&lt;/button>\n  &lt;/div>\n  @if (messages().length > 0) &#123;\n    &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; border: 1px solid black; overflow-y: auto;\">\n      &lt;app-messages [messages]=\"messages()\">&lt;/app-messages>\n    &lt;/div>\n  &#125; @else &#123;\n    &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; justify-content: center; align-items: center; border: 1px solid black;\">\n      &lt;div>No messages&lt;/div>\n    &lt;/div>\n  &#125;\n  &lt;div style=\"margin: 1rem; display: flex; gap: 1rem; align-items: stretch;\">\n    &lt;div style=\"height: 4rem; flex-grow: 1;\">\n      &lt;app-message-input>&lt;/app-message-input>\n    &lt;/div>\n    &lt;div style=\"display: flex; align-items: center;\">\n      &lt;button type=\"button\" style=\"height: 100%;\">Send&lt;/button>\n    &lt;/div>\n  &lt;/div>\n&lt;/div>\n\n\n第 3 行改為顯示聊天室名稱，由 chatroom.component.ts 中的 chatroom()?.name 獲得，此處的 chatroom() 有可能為 undefined 而無法取得 name 屬性，因此使用 ?. 避免取值而造成 Uncaught TypeError: Cannot read properties of undefined 錯誤\n?. 稱為可選串連（optional chaining）運算子\n\n\n第 6 ~ 14 行判斷若 messages() 陣列不為空，則顯示 messages 元件，否則顯示 No messages 字樣\n第 6 行的 @if 是一種控制流語法，以括號內的條件式判斷是否進入其大括號內的區域\n第 8 行的用意是將 messages() 陣列輸入給 messages 元件，並在其中進行排版與樣式的設定\n第 10 行的 @else 也是一種控制流語法，針對 @if 條件式不符的情況進入其大括號內的區域\n\n\n\n\n在 messages.component.ts 以輸入接受上層元件給予的 MessageModel 陣列，並在 messages.component.html 顯示。  import &#123; Component, input &#125; from '@angular/core';\nimport &#123; MessageModel &#125; from '../../../../models/chatroom.model';\n\n@Component(&#123;\n  selector: 'app-messages',\n  imports: [],\n  templateUrl: './messages.component.html',\n  styleUrl: './messages.component.css'\n&#125;)\nexport class MessagesComponent &#123;\n  messages = input&lt;Array&lt;MessageModel>>();\n&#125;\n\n\n第 11 行接受父元件的輸入 MessageModel 陣列來建立 signal messages ，以提供 messages.component.html 顯示  @for (message of messages(); track message.timestamp) &#123;\n  &lt;div style=\"width: fit-content; margin-bottom: 0.5rem; padding: 0.5rem; display: flex; flex-direction: column; gap: 4px; border: 1px solid black; border-radius: 0.5rem;\">\n    &lt;div>&lt;b>&#123;&#123; message.name &#125;&#125;&lt;/b>&lt;/div>\n    &lt;div>&#123;&#123; message.content &#125;&#125;&lt;/div>\n    &lt;div style=\"font-size: 0.6rem;\">&#123;&#123; message.timestamp &#125;&#125;&lt;/div>\n  &lt;/div>\n&#125;\n第 1 行的 @for 是一種控制流語法，使用方式與解說可參考 hall.component.html ，差別在於此處所追蹤的唯一識別碼為訊息的 timestamp\n\n最後，我們可以看到在左圖顯示兩個聊天室連結，可以點擊進入不同聊天室。進入聊天室後，若訊息陣列不為空（右圖上）則將每一筆訊息的內容由上而下顯示出來，否則（右圖下）顯示 No messages 字樣：\n\n\n依賴注入（dependency injection, DI）上述提到的依賴注入是一個著名的設計模式，讓我們將其拆開分別介紹：\n\n依賴（dependency）應用程式中的元件需要取得自身以外的資料或功能來使用。\n注入（injection）當元件需要這些功能時，注入器會去 registry 中找尋並返回或建立一個實體，將它注入至元件。\n\nAngular 的 DI 系統運作大致如下：\n\n應用程式啟動時，將提供者（provider）註冊到 registry 。\n提供者內容包含的令牌（token）是用來查找依賴（dependency）的標識符，它可以是字串、類別或自定義物件。使用令牌可以讓 DI 系統知道應該提供哪個依賴項實體。\n注入器（injector）是一個服務，當某個元件需要某個依賴時，會以令牌向注入器發出請求，注入器解析令牌並返回相應的依賴項實體。\n\n\n\n經由這個運作機制，針對相同的令牌，注入器永遠都會返回相同的實體，因此服務在 Angular 中以單體模式（singleton）實現，它能保證在元件間互通資料的一致性。\n\n每個元件都有屬於自己的注入器，當某個依賴找不到時，會往父層找直到根注入器，此處即為裝飾子 @Injectable() 內部參數 providedIn: &#39;root&#39; 所處的層級。設定在根注入器的服務，能讓所有的元件都能找到。例如，若直到根注入器仍未能找到 ChatroomService 服務，則會跳出 NullInjectorError: No provider for ChatroomService! 錯誤。\n\n\nAngular 的內建服務\nRouter\n在 app.config.ts 將 provideRouter(routes) 加入至 providers 陣列\n由 @angular/router 匯入\n細節請參考 Angular 新手村 - 3. 路由\n\n\nHttpClient\n在 app.config.ts 將 provideHttpClient() 加入至 providers 陣列\n由 @angular/common/http 匯入\n讓我們可以使用 RESTful API 的方式發送 HTTP 請求（request）並接收來自後端的資料http = inject(HttpClient);\nngOnInit() &#123;\n  this.http.get('https://jsonplaceholder.typicode.com/posts').subscribe(console.log);\n&#125;\n\n\nTitle\n由 @angular/platform-browser 匯入\n取得或改變頁面的標題（特別是在 SPA 的情況下，針對不同的元件而動態調整）inject(Title).setTitle(&#39;聊天室&#39;);\n\n\nMeta\n由 @angular/platform-browser 匯入\n取得或改變頁面的 “meta” 值inject(Meta).addTag(&#123; name: &#39;author&#39;, content: &#39;Kun-Neng&#39; &#125;);\n\n\n\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 5. 指令","url":"/2025/02/09/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-5-%E6%8C%87%E4%BB%A4/","content":"指令（directive）非常相似於元件（component），生命週期及參數設定上與元件十分類似，差別在於它不需要範本（template），其目的在於改變元件的佈局（layout）、樣式或者賦予元件特定的行為（例如，使元件能夠被拖曳）。\n指令的類型\n\n由上圖可知，指令有以下三種類型。\n\n元件（component）：細節請參考 Angular 新手村 - 2. 元件\n\n結構型指令（structural directives）：用來操作 DOM 的結構，通常會加上星號（ * ）前綴 *ngIf 、 *ngFor 、 *ngSwitch 使用\n\n注意：對於一個宿主元素，僅允許套用一個結構型指令\n\n以 hall 顯示聊天室陣列 chatrooms() 為例，比較 @for 與 ngFor 的差異：\n\n控制流語法 @for@for (chatroom of chatrooms(); track chatroom.id) &#123;\n  &lt;a [routerLink]=\"['/chatroom', chatroom.id]\">\n    &lt;div style=\"margin: 2px 0; padding: 4px; border: 1px solid blue; border-radius: 4px;\">\n      &#123;&#123; chatroom.name &#125;&#125;\n    &lt;/div>\n  &lt;/a>\n&#125;\n結構型指令 ngFor\n在 hall.component.ts 檔匯入 NgFor 並加入trackChatroomId(index: number, item: ChatroomModel) &#123;\n  return item.id;\n&#125;\n在 hall.component.html 改寫為&lt;a *ngFor=\"let chatroom of chatrooms(); trackBy: trackChatroomId\" [routerLink]=\"['/chatroom', chatroom.id]\">\n  &lt;div style=\"margin: 2px 0; padding: 4px; border: 1px solid blue; border-radius: 4px;\">\n    &#123;&#123; chatroom.name &#125;&#125;\n  &lt;/div>\n&lt;/a>\n\n\n\n以 chatroom 顯示訊息陣列 messages() 為例，比較 @if 與 ngIf 的差異：\n\n控制流語法 @if@if (messages().length > 0) &#123;\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; border: 1px solid black; overflow-y: auto;\">\n    &lt;app-messages [messages]=\"messages()\">&lt;/app-messages>\n  &lt;/div>\n&#125; @else &#123;\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; justify-content: center; align-items: center; border: 1px solid black;\">\n    &lt;div>No messages&lt;/div>\n  &lt;/div>\n&#125;\n結構型指令 ngIf\n在 chatroom.component.ts 檔匯入 NgIf\n在 chatroom.component.html 改寫為&lt;div *ngIf=\"messages().length > 0; else noMessageTemplate\" style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; border: 1px solid black; overflow-y: auto;\">\n  &lt;app-messages [messages]=\"messages()\">&lt;/app-messages>\n&lt;/div>\n&lt;ng-template #noMessageTemplate>\n  &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-grow: 1; justify-content: center; align-items: center; border: 1px solid black;\">\n    &lt;div>No messages&lt;/div>\n  &lt;/div>\n&lt;/ng-template>\n若 messages().length &gt; 0 則顯示 messages 元件；否則，切換到名為 noMessageTemplate 的範本，以顯示 No messages 字樣。\n\n\n\n\n屬性型指令（attribute directive）：改變元件的樣式、賦予指令或元件特定的行為，而非 DOM 的佈局\n\nngModel將物件或值綁定到 HTML 的互動控制項（control），例如以下的輸入框內的值與變數 name 雙向綁定&lt;input [(ngModel)]=\"name\" />\nngStyle在 HTML 元素動態加入行內（inline）樣式，例如以下 div 的字體顏色由 textColor 變數提供，而字體大小由 fontSize 變數提供&lt;div [ngStyle]=\"&#123; 'color': textColor, 'font-size': fontSize &#125;\">動態字體顏色與大小測試&lt;/div>\nngClass在 HTML 元素動態加入 CSS 類別，例如以下 div 的 active 屬性啟動與否由 isActive 變數的真偽值所給定，而 visible 屬性的啟動與否由 isVisible 變數的真偽值所給定&lt;div [ngClass]=\"&#123; 'active': isActive, 'visible': isVisible &#125;\">動態 CSS 類別測試&lt;/div>\n\n\n\n\n\n如同元件，我們一樣可以使用 Angular CLI 快速建立新的指令。\n自定義屬性型指令例如，建立一個替按鈕添加不同樣式的屬性型指令，步驟如下。\n\n在 src/app/shared/directives 資料夾內建立一個指令：  ng generate directive shared/directives/button 或 ng g d shared/directives/button\n\n在 button.directive.ts 內加入：\n  import &#123; Directive, ElementRef, inject, input, OnInit &#125; from '@angular/core';\n\n@Directive(&#123;\n  selector: 'button[appButton]',\n  host: &#123;\n    '[style.padding]': \"'0.5rem 1rem'\",\n    '[style.display]': \"'inline-flex'\",\n    '[style.alignItems]': \"'center'\",\n    '[style.fontSize]': \"'1rem'\",\n    '[style.fontWeight]': \"'500'\",\n    '[style.borderWidth]': \"'1px'\",\n    '[style.borderRadius]': \"'0.375rem'\",\n    '[style.boxShadow]': \"'0 0.5rem 1rem rgba(0, 0, 0, 0.15)'\",\n    '[style.cursor]': \"'pointer'\",\n    '(mouseenter)': 'onMouseEnter()',\n    '(mouseleave)': 'onMouseLeave()'\n  &#125;\n&#125;)\nexport class ButtonDirective implements OnInit &#123;\n  readonly element = inject&lt;ElementRef&lt;HTMLElement>>(ElementRef);\n\n  color = input&lt;'primary' | 'accent' | 'red' | 'white'>('primary');\n\n  ngOnInit(): void &#123;\n    switch (this.color()) &#123;\n      case 'primary':\n        this.element.nativeElement.style.color = 'white';\n        this.element.nativeElement.style.backgroundColor = 'blue';\n        this.element.nativeElement.style.borderColor = 'transparent';\n        break;\n      case 'accent':\n        this.element.nativeElement.style.color = 'white';\n        this.element.nativeElement.style.backgroundColor = 'green';\n        this.element.nativeElement.style.borderColor = 'transparent';\n        break;\n      case 'red':\n        this.element.nativeElement.style.color = 'white';\n        this.element.nativeElement.style.backgroundColor = 'red';\n        this.element.nativeElement.style.borderColor = 'transparent';\n        break;\n      case 'white':\n        this.element.nativeElement.style.color = 'black';\n        this.element.nativeElement.style.backgroundColor = 'white';\n    &#125;\n  &#125;\n\n  onMouseEnter() &#123;\n    this.element.nativeElement.style.boxShadow = '0 0.5rem 1rem rgba(0, 0, 0, 0.25)';\n\n    switch (this.color()) &#123;\n      case 'primary':\n        this.element.nativeElement.style.backgroundColor = 'darkblue';\n        break;\n      case 'accent':\n        this.element.nativeElement.style.backgroundColor = 'darkgreen';\n        break;\n      case 'red':\n        this.element.nativeElement.style.backgroundColor = 'darkred';\n        break;\n      case 'white':\n        this.element.nativeElement.style.backgroundColor = 'lightgray';\n    &#125;\n  &#125;\n\n  onMouseLeave() &#123;\n    this.element.nativeElement.style.boxShadow = '0 0.5rem 1rem rgba(0, 0, 0, 0.15)';\n\n    switch (this.color()) &#123;\n      case 'primary':\n        this.element.nativeElement.style.backgroundColor = 'blue';\n        break;\n      case 'accent':\n        this.element.nativeElement.style.backgroundColor = 'green';\n        break;\n      case 'red':\n        this.element.nativeElement.style.backgroundColor = 'red';\n        break;\n      case 'white':\n        this.element.nativeElement.style.backgroundColor = 'white';\n    &#125;\n  &#125;\n&#125;\n  解析上述服務程式碼：\n\n\n\n第 3 ~ 18 行在類別（class）前加註 @Directive 裝飾子，即告訴 Angular 這個類別被視為指令\n第 4 行設定滿足宿主標籤為 button 並保有 appButton 屬性（attribute）才會套用此指令\n第 5 ~ 17 行賦予宿主元素預設樣式及觸發事件，語法結構如下：\nhost: &#123;\n  '[property]': 'expression', // 將宿主的 property 屬性賦予 expression 值\n  '(eventtype)': 'statement()' // 當事件觸發時，執行 statement() 函式\n&#125;\n\n\n\n第 20 行把 ElementRef 注入至指令中，為的是讓指令能夠存取它的宿主元素，而 ElementRef 參考的型態為 HTMLElement ，此型態唯一擁有的欄位 nativeElement 是底層 DOM 元素的參考（reference），讓我們可以針對 DOM 元素進行操作\n第 22 行為輸入訊號（signal） color ，只能接受某幾種字串，預設值為 primary 字串\n第 24 ~ 45 行在指令初始化時，根據 color() 值以 element.nativeElement.style 賦予宿主元素不同的字體顏色、背景顏色與框線顏色等樣式\n第 47 ~ 63 行對應到第 15 行，當滑鼠移到宿主上觸發 onMouseEnter() 以改變宿主樣式\n第 65 ~ 81 行對應到第 16 行，當滑鼠離開宿主時觸發 onMouseLeave() 以改變宿主樣式\n\n\n記得在 hall.component.ts 將 ButtonDirective 匯入後，並在 hall.component.html 加入至 &lt;button&gt; 中才能看到效果。\n\n下圖呈現不同的參數與事件造成的按鈕樣式上的改變：\n\n\n指令可以套用在多個按鈕上，因此若我們有許多按鈕需要設定樣式，可以在宿主元素匯入此指令，並在標籤中加入 appButton ，針對不同的樣式給定不同的 color 值即可。\n自定義結構型指令想定一個場景：在某個聊天室中，只要顯示在某個時間點後的訊息，步驟如下。\n\n在 src/app/shared/directives 資料夾內建立一個指令：  ng generate directive shared/directives/message-filter 或 ng g d shared/directives/message-filter\n\n在 message-filter.directive.ts 內加入：\n  import &#123; Directive, inject, Input, TemplateRef, ViewContainerRef &#125; from '@angular/core';\n\n@Directive(&#123;\n  selector: '[appMessageFilter]'\n&#125;)\nexport class MessageFilterDirective &#123;\n  private vcr = inject(ViewContainerRef);\n  private tpl = inject&lt;TemplateRef&lt;any>>(TemplateRef);\n\n  @Input() set appMessageFilter(condition: boolean) &#123;\n    if (condition) &#123;\n      this.vcr.createEmbeddedView(this.tpl);\n    &#125; else &#123;\n      this.vcr.clear();\n    &#125;\n  &#125;\n&#125;\n  解析上述程式碼：\n\n\n\n第 7 行注入的 ViewContainerRef 可視為一個可以置入／移出子視圖（view）的盒子。為了標註這些容器（container）， Angular 在所建立的 DOM 中使用特別的 HTML 註解。當接收到輸入值時，它會判斷要在此特別的註解位置置入或移出該子視圖。\n這樣的設計概念讓 Angular 得以僅更新已改變的視圖，而非整個元件範本。\n\n\n第 8 行注入的 TemplateRef 代表指令所加入的 ng-template\n第 10 ~ 15 行接收一個布林輸入值 condition ，根據此布林值決定範本顯示與否\n\n\n在 messages.component.ts 中匯入此指令，並加上篩選條件函式 isFiltered ：  // 略\nimport &#123; MessageFilterDirective &#125; from '../../../../shared/directives/message-filter.directive';\n\n@Component(&#123;\n  selector: 'app-messages',\n  imports: [DatePipe, MessageFilterDirective], // ←\n  templateUrl: './messages.component.html',\n  styleUrl: './messages.component.css'\n&#125;)\nexport class MessagesComponent &#123;\n  // 略\n\n  private filterTimestamp = 1609430401000;\n\n  isFiltered(messageTimestamp: string) &#123;\n    return Date.parse(messageTimestamp) >= this.filterTimestamp;\n  &#125;\n&#125;\n  解析上述程式碼：\n\n\n第 13 行加入用來篩選的時間戳記（為了展示說明，把值寫死在此處）\n第 15 ~ 17 行接收時間戳記字串 messageTimestamp ，經過比較運算後返回該訊息時間是否在給定的時間之後\n\n\n在 messages.component.html 加入指令：  &lt;div *appMessageFilter=\"isFiltered(message.timestamp)\" ...\n  解析上述程式碼：\n\n\n加上星號（ * ）前綴以使用 appMessageFilter 指令，並以 isFiltered 函式處理訊息的時間戳記\n\n試著在 chatroom.service.ts 添加更多不同時間戳記的訊息或變更 filterTimestamp ，可看出只會顯示所給定時間點後的訊息：\n\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 6. 管道","url":"/2025/03/29/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-6-%E7%AE%A1%E9%81%93/","content":"有時候我們不會想在視圖（view）直接呈現原始資料，而是將它們轉換或格式化等再顯示出來。這些瑣碎、重複的事情就可以由 Angular 提供的管道（pipe）來完成。做法通常是在範本插值（ template interpolation ）中，於原始資料後串接 | 及特定管道即可。\n內建管道\nasync\n\nAsyncPipe 處理並呈現來自 Promise 或 Observable 的非同步資料，當資料可用時，它會觸發一個改變偵測（change detection）檢查\n若來源為 Observable ，則當此管道被銷毀時，會反訂閱該來源。\n\n\n\n\nkeyvalue\n\nKeyValuePipe 在 Angular 6.1 被提出，針對 Map 或物件元素進行迭代並取出鍵（key）值（value），其鍵的順序按照以下規則：\n如果它們都是字串，則按字典順序排列；\n如果它們都是數字，則按數值順序排列；\n如果它們都是布林值（先 false 後 true），則按它們的布林值計算；如果鍵的類型不同，則先將它們轉換為字串，再進行比較。\n\n\n\n\nuppercase\n\nUpperCasePipe 轉換字串為大寫\n例如， &#123;&#123; 'chatroom name' | uppercase &#125;&#125; 顯示為 CHATROOM NAME\n\n\nlowercase\n\nLowerCasePipe 轉換字串為小寫\n例如， &#123;&#123; 'CHATROOM NAME' | lowercase &#125;&#125; 顯示為 chatroom name\n\n\ntitlecase\n\n在 Angular 4 被提出， TitleCasePipe 轉換每個字的首字為大寫\n例如， &#123;&#123; 'chatroom name' | titlecase &#125;&#125; 顯示為 Chatroom Name\n\n\njson\n\nJsonPipe 使用 JSON.stringify() 來呈現資料，通常使用在開發階段，以快速檢視資料內容。\n\n\n\n\n\n\nslide\n\nSlicePipe 用來部分顯示列表中的元素，它接受兩個引數（argument）：起始索引（start index）與可選的結束索引（end index）。要提供引數，必須在管道後串接 : ，再串接第一個引數。若有第二個引數，則再串接 : 及第二個引數。\n例如，第 11 行以 slice:1:3 取出 chatrooms() 陣列中第 1 個與第 2 個元素，並以 json 管道顯示物件內容。import &#123; Component, signal &#125; from '@angular/core';\nimport &#123; JsonPipe, SlicePipe &#125; from '@angular/common';\nimport &#123; ChatroomModel &#125; from '../../models/chatroom.model';\n\n@Component(&#123;\n  selector: 'app-hall',\n  imports: [SlicePipe, JsonPipe],\n  template: `\n    &lt;div style=\"height: 100%; display: flex; flex-direction: column;\">\n      &lt;div style=\"margin: 1rem; padding: 1rem; display: flex; flex-direction: column; flex-grow: 1; justify-content: start; border: 1px solid black; overflow-y: auto;\">\n        @for (chatroom of chatrooms() | slice:1:3; track chatroom.id) &#123;\n          &lt;div style=\"margin: 2px 0; padding: 4px; border: 1px solid blue; border-radius: 4px;\">\n            &#123;&#123; chatroom | json &#125;&#125;\n          &lt;/div>\n        &#125; @empty &#123;\n          &lt;div>No chatrooms&lt;/div>\n        &#125;\n      &lt;/div>\n    &lt;/div>\n  `\n&#125;)\nexport class HallComponent &#123;\n  chatrooms = signal&lt;Array&lt;ChatroomModel>>([\n    &#123; id: 1, name: 'Chatroom A', messages: [\n      &#123; timestamp: '2021-01-01 00:00:00', name: 'Alice', content: 'Hello, World!' &#125;,\n      &#123; timestamp: '2021-01-01 00:00:01', name: 'Bob', content: 'Hi, Alice!' &#125;\n    ] &#125;,\n    &#123; id: 2, name: 'Chatroom B', messages: [\n      &#123; timestamp: '2022-01-02 00:00:00', name: 'David', content: 'Good afternoon!' &#125;\n    ] &#125;,\n    &#123; id: 3, name: 'Chatroom C', messages: [\n      &#123; timestamp: '2022-01-01 00:00:00', name: 'Cindy', content: 'Good morning!' &#125;\n    ] &#125;,\n    &#123; id: 4, name: 'Chatroom D', messages: [] &#125;,\n    &#123; id: 5, name: 'Chatroom E', messages: [] &#125;,\n  ]);\n&#125;\n由下圖可看出僅呈現第 1 個與第 2 個 ChatroomModel 物件在經過字串化的結果：\n\n\ndate\n\nDatePipe 將時間（ Date 物件或毫秒數值）轉換成想要的字串格式，如 &#39;yyyy/MM/dd&#39; 、 &#39;yy-MM&#39; 或預先定義的符號 &#39;short&#39; 或 &#39;longDate&#39; 等\n例如，在 Chapter 4 - 服務（service） 的 Messages 元件中加入並使用 DatePipe 將 timestamp 轉換成滿足 yyyy&#x2F;MM&#x2F;dd HH:mm 格式的時間顯示方式：// 略\nimport &#123; DatePipe &#125; from '@angular/common';\n\n@Component(&#123;\n  selector: 'app-messages',\n  imports: [DatePipe], // ←\n  templateUrl: './messages.component.html',\n  styleUrl: './messages.component.css'\n&#125;)\nexport class MessagesComponent &#123;\n  // 略\n&#125;\n@for (message of messages(); track message.timestamp) &#123;\n  &lt;div style=\"width: fit-content; margin-bottom: 0.5rem; padding: 0.5rem; display: flex; flex-direction: column; gap: 4px; border: 1px solid black; border-radius: 0.5rem;\">\n    &lt;div>&lt;b>&#123;&#123; message.name &#125;&#125;&lt;/b>&lt;/div>\n    &lt;div>&#123;&#123; message.content &#125;&#125;&lt;/div>\n    &lt;div style=\"font-size: 0.6rem;\">&#123;&#123; message.timestamp | date:'yyyy/MM/dd HH:mm' &#125;&#125;&lt;/div>\n  &lt;/div>\n&#125;\n由下圖可看出原始資料 2021-01-01 00:00:00 被轉換成 2021/01/01 00:00 字串顯示出來：\n\n\nnumber\n\nDecimalPipe 它接受一個字串引數（argument），格式為 &#123;integerDigits&#125;.&#123;minFractionDigits&#125;-&#123;maxFractionDigits&#125; ，其中每個部分都是可選的，分別為\nintegerDigits ：整數部分需要多少個數字（整數位數）\n如果給定的 integerDigits 多過於整數位數，則會補 0\n\n\nminFractionDigits ：小數部分至少需要多少個數字\nmaxFractionDigits ：小數部分最多有幾個數字\n如果小數位數多過於給定的數字，則會四捨五入\n\n\n\n\n例如，定義 value = 1111.25 則\n&#123;&#123; value | number &#125;&#125; 顯示為 1,111.25\n&#123;&#123; value | number:'6.' &#125;&#125; 顯示為 001,111.25\n&#123;&#123; value | number:'.1-2' &#125;&#125; 顯示為 1,111.25\n&#123;&#123; value | number:'.1-1' &#125;&#125; 顯示為 1,111.3\n\n\n\n\ncurrency\n\nCurrencyPipe 將金錢數字以給定的貨幣格式顯示，因此必須提供至少一個參數：\n貨幣的 ISO 代碼，例如 &#39;USD&#39; 、 &#39;EUR&#39; 或 &#39;JPY&#39; 等\n若要在前綴加入金錢符號（ &#39;$&#39; 、 &#39;€&#39; 、 &#39;CA$&#39; 等），可使用符號（ symbol 或 symbol-narrow ）。前者為完整的貨幣符號，後者為簡化的貨幣符號。\n\n\n例如，定義 amount = 1234.56 則\n&#123;&#123; amount | currency:'USD' &#125;&#125; 顯示為 $1,234.56\n&#123;&#123; amount | currency:'EUR':'symbol':'1.2-2' &#125;&#125; 顯示為 €1,234.56\n&#123;&#123; amount | currency:'CAD':'symbol' &#125;&#125; 顯示為 CA$1,234.56\n&#123;&#123; amount | currency:'CAD':'symbol-narrow' &#125;&#125; 顯示為 $1,234.56\n&#123;&#123; amount | currency:'JPY':'symbol-narrow' &#125;&#125; 顯示為 ¥1,235\n\n\n\n\npercent\n\nPercentPipe 將數字以百分比形式顯示\n例如，定義 value = 0.25 則 &#123;&#123; value | percent &#125;&#125; 顯示為 25%\n\n\n\n除了在範本插值使用外，我們也可以將它加在程式碼中，例如要改變一個數字的格式，可以使用 formatNumber 函式：\nimport &#123; Component, computed, signal &#125; from '@angular/core';\nimport &#123; formatNumber &#125; from '@angular/common'; // ←\n\n@Component(&#123;\n  selector: 'app-dog',\n  template: `&lt;p>&#123;&#123; formattedWeight() &#125;&#125;&lt;/p>`\n&#125;)\nexport class DogComponent &#123;\n  dog = signal(&#123; name: 'Cute Dog', weight: 15 &#125;);\n\n  formattedWeight = computed(\n    () => formatNumber(this.dog().weight, 'en-US', '.2')\n  );\n&#125;\n\n客製化管道要客製化一個管道，簡單來說，就是實作 PipeTransform 介面。例如，我們利用管道將足球圓周轉換為大小，可以將判斷式加入至 transform() 方法，並返回結果。\nimport &#123; Pipe, PipeTransform &#125; from '@angular/core';\n\n@Pipe(&#123;\n  name: 'size'\n&#125;)\nexport class SizePipe implements PipeTransform &#123;\n  transform(value: number, ...args: Array&lt;unknown>): string &#123;\n    if (value >= 27 &amp;&amp; value &lt;= 28) &#123;\n      return '5';\n    &#125; else if (value >= 25 &amp;&amp; value &lt; 27) &#123;\n      return '4';\n    &#125; else if (value >= 23 &amp;&amp; value &lt; 25) &#123;\n      return '3';\n    &#125; else &#123;\n      return 'Other';\n    &#125;\n  &#125;\n&#125;\n\n使用上，將 SizePipe 匯入後，即可在範本插值使用。\nimport &#123; Component, signal &#125; from '@angular/core';\nimport &#123; SizePipe &#125; from '...'; // ←\n\n@Component(&#123;\n  selector: 'app-soccer',\n  imports: [SizePipe], // ←\n  template: 'The soccer size is &#123;&#123; soccerBall().circumference | size &#125;&#125;',\n&#125;)\nexport class SoccerBallComponent &#123;\n  soccerBall = signal(&#123;\n    circumference: 26.5\n  &#125;);\n&#125;\n\n在網頁上即可見到由客製化的管道轉換後的結果。\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 7. 生命週期","url":"/2025/04/05/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-7-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F/","content":"我們能看到 Angular 應用程式的運作畫面，都是由元件組成並呈現，而稍微複雜的系統，勢必會有元件或資訊上的顯示、隱藏、變更等操作。這些都與生命週期（ life cycle ）牽扯不了關係。要打造一個穩定可靠的應用程式，不得不從最基礎的元件來了解其生命週期。\nAngular 的生命週期流程大致如下圖所示。每一個方框都代表 Angular 的運行狀態，會呼叫對應的內建函式，稱為鉤子（ hook ）。例如，某個元件首次被觸發顯示時，會依粗箭頭呼叫 ngOnChanges -&gt; ngOnInit -&gt; ngDoCheck -&gt; … 等鉤子。即使在程式中不見得會直接使用到，但 Angular 背後的生命週期仍按照這些鉤子運作。\nflowchart TD\n  Start((\"開始\")) ==> ngOnChanges(\"ngOnChanges\")\n  ngOnChanges(\"ngOnChanges\"):::change ==> ngOnInit(\"ngOnInit\")\n  ngOnInit(\"ngOnInit\"):::init ==> ngDoCheck(\"ngDoCheck\")\n  ngDoCheck(\"ngDoCheck\"):::change ==> ngAfterContentInit(\"ngAfterContentInit\")\n  ngAfterContentInit(\"ngAfterContentInit\"):::init ==> ngAfterContentChecked(\"ngAfterContentChecked\")\n  ngAfterContentChecked(\"ngAfterContentChecked\"):::change ==> ngAfterViewInit(\"ngAfterViewInit\"):::init\n  ngAfterViewInit(\"ngAfterViewInit\") ==> ngAfterViewChecked(\"ngAfterViewChecked\")\n  ngAfterViewChecked(\"ngAfterViewChecked\"):::change --> ngOnDestroy(\"ngOnDestroy\"):::destroy\n  ngOnDestroy(\"ngOnDestroy\") --> Stop(((\"結束\")))\n\n  Change((\"變更\")) -.-> ngOnChanges(\"ngOnChanges\")\n  ngOnChanges(\"ngOnChanges\") -.-> ngDoCheck(\"ngDoCheck\")\n  ngDoCheck(\"ngDoCheck\") -.-> ngAfterContentChecked(\"ngAfterContentChecked\")\n  ngAfterContentChecked(\"ngAfterContentChecked\") -.-> ngAfterViewChecked(\"ngAfterViewChecked\")\n\n  classDef init stroke:#0f0\n  classDef destroy stroke:#f00\n  classDef change stroke:#00f\n\n由上圖我們可以歸納出幾個重點：\n\n綠色方框為元件在首次觸發才會呼叫的鉤子\n藍色方框為元件不管在首次觸發，或往後偵測到變更時，都會觸發的鉤子（其中只有 ngOnChanges 是針對 input 的變更才觸發）\n紅色方框為元件結束時才會呼叫的鉤子\n\n一般常用的鉤子有以下三種：\n\nngOnChanges: 當一個或多個綁定的 input 值發生改變時，呼叫此鉤子。它會獲得一個 SimpleChange 型別的 map ，其包含各個 input 目前值（ currentValue ）與之前值（ previousValue ）。若沒有任何變更，此鉤子不會被呼叫。\nngOnInit: 首次觸發，在 ngOnChanges 後（若有變更的話）僅呼叫一次，進行初始化行為。它被呼叫時的情況有以下兩種：\n沒有 input ，會呼叫此鉤子\n有 input ，在第一次的 ngOnChanges 後呼叫此鉤子\n\n\nngOnDestroy: 當元件結束時才會呼叫的鉤子，對於清理行為（ cleanup ）很有幫助。\n\n\n\nngOnInit若要操作鉤子內的行為，建議在元件加入 implements 來實作它，這樣的方式確保能正確取得鉤子進行操作。例如，當在 CarComponent 實作 OnInit (1) ，若程式碼未加入 ngOnInit() 函式 (2) ，則編譯階段就會報錯。\nexport class CarComponent implements OnInit &#123; // ← (1)\n  ngOnInit() &#123; // ← (2)\n    // Do something\n  &#125;\n&#125;\n\nngOnChanges如果想要每次在 input 值變更時做一些行為，可以使用 OnChanges 鉤子。 ngOnChanges 函式的參數 changes 是一筆記錄，以 input 名稱為鍵（ key ），其值（ value ）為 SimpleChange 物件，包含\n\ncurrentValue 與 previousValue 分別存放目前值與之前值\nisFirstChange() 用來判斷此次變更是否為第一次的變更。\n\nexport class CarComponent implements OnChanges &#123;\n  color = input.required&lt;string>();\n\n  ngOnChanges(changes: SimpleChanges): void &#123;\n    const carChange = changes['color'];\n    console.log(`Color changed from $&#123;carChange.previousValue&#125; to $&#123;carChange.currentValue&#125;`);\n    console.log(`Is it the first change? $&#123;carChange.isFirstChange()&#125;`);\n    console.log(`My new color is $&#123;this.color()&#125;`); // 目前 input 值\n  &#125;\n&#125;\n\nngOnDestroyngOnDestroy 鉤子設計用來銷毀元件。假設一個元件 CarComponent 建立時，每秒顯示字串 “Hello” ，當元件結束時就必須取消背景執行的工作，意即停止 setInterval 以避免記憶體洩漏（ memory leak ）問題。否則， JavaScript 會一直將此元件的實體（ instance ）保持在記憶體中，每秒顯示字串，直到永遠。\nexport class CarComponent implements OnDestroy &#123;\n  color = input.required&lt;string>();\n  private interval: number;\n\n  constructor() &#123;\n    this.interval = window.setInterval(() => &#123;\n      console.log('Hello');\n    &#125;, 1000);\n  &#125;\n\n  ngOnDestroy(): void &#123;\n    window.clearInterval(this.interval);\n  &#125;\n&#125;\n\n任何鉤子在 Angular 的生命週期都有其特別的用途，許多時候相同的行為（例如取值）會因為在不同的鉤子而得到不同的結果，這些問題或解法通常都會出現以下鉤子中：\nngDoCheck雖然 ngOnChanges 與 ngDoCheck 是不管在首次觸發，或往後偵測到變更時，都會觸發的鉤子，差別在於偵測變更的部分。 ngOnChanges 只針對 input 值的變更，精確來說，是對 input 的參考（ reference ）變更。倘若 input 值是物件型別或陣列，內部參數值的變化並不會影響到 input 的參考，因此就不會觸發 ngOnChanges 鉤子。這種情況下，我們可以經由 ngDoCheck 鉤子取得任何變更。\n\n因為 ngDoCheck 鉤子不管在任何情況下都會觸發，在如此頻繁的呼叫頻率下，要盡量簡化實作邏輯來避免效能降低。\n\nngAfterViewInit 與 ngAfterViewChecked有時候我們想要針對範本中元素（element）的各項資訊或進行操作，可以使用範本參考變數（ template reference variable ）取得該元素的參考。\n以下是幾種應用的範例：\n\n在範本中取得元素資訊\n&lt;input #phone placeholder=\"phone number\" />\n&lt;button type=\"button\" (click)=\"callPhone(phone.value)\">Call&lt;/button>\n只要以 # 搭配變數名稱即可賦予元素變數名稱。例如： input 的範本變數名稱為 phone ，接著就可以呼叫 callPhone 函式，並將 phone.value 傳入執行。\n\n在範本中操作元素行為\n&lt;input #phone />\n&lt;button (click)=\"phone.focus()\">Focus&lt;/button>\n賦予元素 phone 變數名稱，並在按鈕加入觸發 phone.focus() 行為。\n\n在程式碼中取得元素參考並操作元素行為\n@Component(&#123;\n  selector: 'app-login',\n  template: `&lt;input #loginInput [(ngModel)]=\"credentials.login\" />`,\n  imports: [FormsModule]\n&#125;)\nexport class LoginComponent implements AfterViewInit &#123;\n  credentials = &#123; login: '' &#125;;\n  loginInput = viewChild.required&lt;ElementRef&lt;HTMLInputElement>>('loginInput');\n\n  ngAfterViewInit(): void &#123;\n    this.loginInput().nativeElement.focus();\n  &#125;\n&#125;\n解析上述程式碼：\n\n第 3 行我們替 input 宣告 loginInput 變數並在第 8 行取得此元素\n第 8 行的用意是告訴框架：我們需要從範本中查詢一個變數名稱為 loginInput 的元素，以該元素（型別為 ElementRef&lt;T&gt; ）進行訊號（signal）初始化。這個型別僅擁有一個欄位（field），即為型別為 T 的 nativeElement ，它就是對於此元素的參考。\n相較使用 @ViewChild 裝飾子， viewChild 與 viewChild.required 為基於訊號的方式，它永遠能與範本保持同步最新，若元素被銷毀，此訊號將會被設為 undefined\n\n\n第 10 ~ 12 行的 ngAfterViewInit 鉤子會在視圖（view）建立後馬上被呼叫，此時我們能保證該元素已存在並能操作。\n若嘗試在 constructor 取用元素，會報出錯誤訊息 NG0951: Child query result is required but no value is available.；若是在 ngOnInit 鉤子則無法操作元素行為。我們也可以在 ngAfterViewChecked 鉤子操作元素行為，它會在每次變更後的每一次視圖（view）檢查時被呼叫。\n\n\n\n\n\n如果想要在各個不同的元件使用此功能，可以為它建立指令（directive），避免每個元件都存在重複的程式碼。 \nngAfterContentInit 與 ngAfterContentCheckedAngular 框架提供許多提升元件擴充性的方法，其中一項就是讓元件具有動態內容（content）。例如：\n@Component(&#123;\n  selector: 'app-card',\n  template: `\n  &lt;div style=\"padding: 8px; outline: 1px solid black; border-radius: 8px;\">\n    &lt;div>\n      &lt;h3>\n        &lt;ng-content select=\".title\">&lt;/ng-content>\n      &lt;/h3>\n      &lt;p>\n        &lt;ng-content select=\".content\">&lt;/ng-content>\n      &lt;/p>\n    &lt;/div>\n  &lt;/div>\n  `\n&#125;)\nexport class CardComponent &#123; &#125;\n\n以上範本具有兩個 ng-content 元素，各自擁有不同的選擇器 title 與 content ，用來接收外部所賦予的內容。將不同的內容投射至 CardComponent 範本，即可呈現不同的結果。\n範例一：\n&lt;app-card>\n  &lt;div class=\"title\">Happy Birthday&lt;/div>\n  &lt;p class=\"content\">May your birthday mark the beginning of a wonderful period of time in your life!&lt;/p>\n&lt;/app-card>\n\n\n\n範例二：\n&lt;app-card>\n  &lt;div class=\"title\">\n    &lt;i>Merry Christmas&lt;/i>\n  &lt;/div>\n  &lt;div class=\"content\" style=\"display: flex; align-items: flex-start;\">\n    &lt;p style=\"margin-top: 0px;\">Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.&lt;/p>\n    &lt;img src=\"assets/christmas_tree.png\" style=\"max-width: 150px;\" />\n  &lt;/div>\n&lt;/app-card>\n\n\n\n可以看出 title 與 content 類別的元素，會各自填充在 CardComponent 範本的不同區塊，讓元件具備複用性、一致性與擴充性。\n此時若我們仍想要取用這些投射進來的元素，類似視圖（view）使用 viewChild 是無法取得的，而是需要針對 ng-content 標籤使用 contentChild 或 contentChildren 。\n我們以取得 title 的元素為例，步驟如下：\n\n在投射進去的元素內加上 #title 。\n  &lt;div class=\"title\" #title>...&lt;/div>\n\n取得元素後於 ngAfterContentInit 鉤子進行操作。\n  @Component(&#123;\n  selector: 'app-card',\n  template: `\n  &lt;-- 略 -->\n  `\n&#125;)\nexport class CardComponent implements AfterContentInit &#123;\n  title = contentChild.required&lt;ElementRef>('title');\n\n  ngAfterContentInit() &#123;\n    this.title().nativeElement.style.backgroundColor = 'pink';\n  &#125;\n&#125;\n  解析以上程式碼：\n\n\n\n第 8 行以 contentChild 取得變數名稱為 title 的元素\n第 11 行改變該元素的背景顏色\n\n\n\n\n同樣地，使用 ngAfterContentInit 鉤子確保內容可以被取得，而 ngAfterContentChecked 鉤子會在每一次內容（content）檢查時被呼叫。\n\n總結比較 viewChild 與 contentChild 的差異：\n\nviewChild 用來取得元件中直接包含的子元素。\ncontentChild 用來取得存在於父元件的範本中，經由 ng-content 投射至元件中的元素。\n\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular 新手村 - 8. 表單","url":"/2025/05/02/Angular-%E6%96%B0%E6%89%8B%E6%9D%91-8-%E8%A1%A8%E5%96%AE/","content":"表單（ form ）是經常使用在網頁的元素，我們可以用它來驗證使用者的輸入，包含欄位是否已填、符合某種規則之類。 Angular 提供很有用的表單操作模組，可以協助打造具有響應式的表單。例如，我們想要在進入聊天室之前，讓使用者進行註冊或登入後，符合某些條件才能進入聊天室。\n在實作之前，我們介紹 Angular 的 FormControl ，它是表單的最小單元，舉凡 input 或 select 皆可視為一個 FormControl 。\nFormControl 封裝了表單的狀態與內容值，例如\n\ntouched: 使用者曾經進入過 &lt;- 相反 -&gt; untouched: 使用者未曾進入過\nvalid: 滿足表單規則且通過驗證 &lt;- 相反 -&gt; invalid: 未滿足表單規則或未通過驗證\npristine: 使用者未曾改變過值 &lt;- 相反 -&gt; dirty: 使用者改變過值\nvalue: 內容值\nerrors: 表單錯誤資訊的物件\nstatusChanges: 當狀態改變時，一個 Observable 被觸發\nvalueChanges: 當內容值改變時，一個 Observable 被觸發\n\nFormGroup 可以容納一個或數個 FormControl ，它也存在類似 FormControl 的狀態與內容值，因此我們可以用它管理內部所有的 FormControl 。\n範本驅動表單 Template-driven forms\n以範本內的指令建立並操作物件模型\n適用於範本內僅有基本表單需求與邏輯\n可以很直覺地將物件內容顯示在範本\n\n&lt;h2>Sign up&lt;/h2>\n&lt;form #registerForm=\"ngForm\" (ngSubmit)=\"register()\">\n  &lt;fieldset>\n    &lt;label for=\"account\">Account&lt;/label>\n    &lt;input type=\"email\" id=\"account\" name=\"account\" [(ngModel)]=\"user.account\" required />\n    &lt;label for=\"password\">Password&lt;/label>\n    &lt;input type=\"password\" id=\"password\" name=\"password\" [(ngModel)]=\"user.password\" required />\n  &lt;/fieldset>\n  &lt;button type=\"submit\">Register&lt;/button>\n&lt;/form>\n解析上述程式碼：\n\n第 2 行定義一個範本參考變數 registerForm ，其參考由 Angular 針對此表單所建立的 NgForm 物件實體\n第 5 行與第 7 行的 [(ngModel)] 是一種雙向綁定（ two-way binding ）的語法，整合輸入與輸出的行為。\n輸入 user.account 至表單： [ngModel]=&quot;user.account&quot;\n由表單輸出 user.account ： (ngModelChange)=&quot;user.account = $event&quot;\n\n\n第 9 行的按鈕被定義為表單標籤上 ngSubmit 的事件處理器，意旨當 submit 被觸發時， NgForm 會將 ngSubmit 事件發送出去，並且連帶呼叫 register() 函式。\n\nimport &#123; Component &#125; from '@angular/core';\nimport &#123; FormsModule &#125; from '@angular/forms';\n\n@Component(&#123;\n  selector: 'app-register',\n  imports: [FormsModule],\n  templateUrl: 'register.component.html'\n&#125;)\nexport class RegisterFormComponent &#123;\n  user = &#123;\n    account: '',\n    password: ''\n  &#125;;\n\n  register() &#123;\n    // Do something\n    console.log(this.user);\n  &#125;\n&#125;\n解析上述程式碼：\n\n第 6 行匯入 FormsModule\n第 10 ~ 13 行定義 user 物件，提供 ngModel 存取\n第 17 行定義按鈕點選後呼叫的行為\n\n響應式表單 Reactive forms有別於範本驅動表單以範本內的指令建立並操作物件模型，響應式表單以程式撰寫元件類別層級的控制項定義及驗證機制完成表單運作。\n\n在元件類別直接、明確存取底層的物件模型\n適用於以表單為應用程式的關鍵項目\n較具可延展性、可複用性與可測試性\n\n&lt;form [formGroup]=\"userForm\" (ngSubmit)=\"register()\">\n  &lt;fieldset>\n    &lt;label for=\"account\">Account&lt;/label>\n    &lt;input type=\"email\" id=\"account\" formControlName=\"account\" />\n    &lt;label for=\"password\">Password&lt;/label>\n    &lt;input type=\"password\" id=\"password\" formControlName=\"password\" />\n  &lt;/fieldset>\n\n  &lt;button type=\"submit\">Register&lt;/button>\n&lt;/form>\n解析上述程式碼：\n\n第 1 行以 formGroup 指令套用到整個表單，並綁定一個變數名稱 userForm ，其內部每一個 input 都能由 formControlName 綁定對應的 FormControl 並獲得其內容值\n第 4 行與第 6 行由 FormControl 實體化每個控制項\n\nimport &#123; Component, inject &#125; from '@angular/core';\nimport &#123; CommonModule &#125; from '@angular/common';\nimport &#123; FormControl, FormBuilder, ReactiveFormsModule &#125; from '@angular/forms';\n\n@Component(&#123;\n  selector: 'app-register',\n  templateUrl: './register-form.component.html',\n  imports: [CommonModule, ReactiveFormsModule]\n&#125;)\nexport class RegisterFormComponent &#123;\n  private readonly fb = inject(FormBuilder);\n\n  userForm = this.fb.group(&#123; // == new FormGroup(&#123; ... &#125;)\n    account: '', // == new FormControl('')\n    password: '' // == new FormControl('')\n  &#125;);\n\n  register() &#123;\n    // Do something\n    console.log(this.userForm.value);\n  &#125;\n&#125;\n解析上述程式碼：\n\n第 8 行匯入 ReactiveFormsModule\n第 11 行注入 FormBuilder\n第 13 ~ 16 行使用 FormBuilder 提供的函式，幫助我們建立 FormGroup 與 FormControl \n第 20 行直接以 value 取得 user 內容值\n\n\n\n表單樣式\n\n\n初始狀態\n變動狀態\n\n\n\nng-untouched使用者未曾進入過\nng-touched使用者曾經進入過\n\n\nng-pristine使用者未曾改變過值\nng-dirty使用者改變過值\n\n\n\n\n\n未滿足表單規則或未通過驗證\n滿足表單規則且通過驗證\n\n\n\nng-invalid\nng-valid\n\n\n我們可以針對 Angular 表單設定不同狀態的樣式\n.ng-valid[required], .ng-valid.required &#123;\n  border-left: 5px solid green;\n&#125;\n\n.ng-invalid:not(form) &#123;\n  border-left: 5px solid red;\n&#125;\n\n.alert &#123;\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: #FED3D3;\n  color: #820000;\n&#125;\n在範本中加入表單狀態判斷，能因應表單的各種狀態顯示不同的錯誤提醒\n&lt;div *ngIf=\"account.invalid &amp;&amp; (account.dirty || account.touched)\" class=\"alert\" >\n  &lt;ng-container *ngIf=\"account.errors?.['required']\">\n    Account is required.\n  &lt;/ng-container>\n  &lt;ng-container *ngIf=\"account.errors?.['forbiddenName']\">\n    Account cannot begin with admin.\n  &lt;/ng-container>\n&lt;/div>\n\n內建驗證器（built-in validator）官方 Validators 提供以下驗證方法：\nclass Validators &#123;\n  static min(min: number): ValidatorFn; // ← 驗證輸入值大於最小值 min\n  static max(max: number): ValidatorFn; // ← 驗證輸入值小於最大值 max\n  static required(control: AbstractControl&lt;any, any>): ValidationErrors | null; // ← 確保欄位不為空\n  static requiredTrue(control: AbstractControl&lt;any, any>): ValidationErrors | null;\n  static email(control: AbstractControl&lt;any, any>): ValidationErrors | null;\n  static minLength(minLength: number): ValidatorFn; // ← 驗證輸入值長度大於 minLength\n  static maxLength(maxLength: number): ValidatorFn; // ← 驗證輸入值長度小於 maxLength\n  static pattern(pattern: string | RegExp): ValidatorFn;\n  static nullValidator(control: AbstractControl&lt;any, any>): ValidationErrors | null;\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;\n  static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null;\n&#125;\n\n自定義驗證器如果內建驗證器無法滿足需求，可以創建自定義驗證器。例如，驗證輸入值是否含有特定字串：\nexport function forbiddenNameValidator(reg: RegExp): ValidatorFn &#123;\n  return (control: AbstractControl): ValidationErrors | null => &#123;\n    const isForbidden = reg.test(control.value);\n    return isForbidden ? &#123; forbiddenName: &#123; value: control.value &#125; &#125; : null;\n  &#125;\n&#125;\n解析以上程式碼：\n\n第 1 行我們建立一個函式 forbiddenNameValidator 接受一個正規表示式，並返回 ValidatorFn\n第 2 ~ 5 行讓驗證器接受一個控制元件實例並經過規則運算後，返回以下其中一種驗證結果\n成功：null\n失敗：錯誤對映表\n\n\n\nloginForm = new FormGroup(&#123;\n  account: new FormControl('', [\n    Validators.required,\n    forbiddenNameValidator(/admin/i) // ←\n  ]),\n  password: new FormControl('', [\n    Validators.requires,\n    Validators.minLength(6)\n  ])\n&#125;);\n將 forbiddenNameValidator 加入到驗證器的陣列中即可。\n結合驗證器與表單樣式後，可呈現更完整的表單功能\n\n\n總結：\n範本驅動表單的缺點\n\n將範本成為表單驗證規則的來源，會變得難以閱讀和快速維護\n當添加越來越多的驗證器標籤，表單的可讀性和可維護性會降低\n表單驗證邏輯不能簡單地進行單元測試\n\n響應式表單的優點\n\n範本變得簡潔許多，只要專注於實現表現層的邏輯\n響應式表單與內部控制項都提供 RxJs 操作，可以使用清晰好閱讀且易維護的寫法進行資料處理\n檢查 account 是否有值，若有，則將它改為大寫後，驗證是否通過表單規則this.loginForm.valueChanges.pipe(\n  filter((form) => !!form.account),\n  map((form) => form.account.toUpperCase()),\n  filter(() => this.loginForm.valid)\n).subscribe((value) => &#123;\n  console.log(`Valid account: $&#123;JSON.stringify(value)&#125;`);\n&#125;);\n針對 loginForm 內的控制項 password ，不處理 400 毫秒內的連續輸入，若超過 400 毫秒沒再輸入，則檢查其值是否有改變this.loginForm.controls.password.valueChanges.pipe(\n  debounceTime(400),\n  distinctUntilChanged()\n).subscribe((value) => &#123;\n  this.passwordStrength = value ? value.length : 0;\n&#125;);\n\n\n有助於實現更進階的使用案例，如根據後端資料來動態定義表單fetchFormFields(): Observable&lt;FormField[]> &#123;\n  // 此處模擬收到由後端傳來的資料\n  return of([\n    &#123; name: 'username', type: 'text', label: 'User Name', required: true &#125;,\n    &#123; name: 'email', type: 'email', label: 'Email', required: true &#125;,\n    &#123; name: 'age', type: 'number', label: 'Age', required: false &#125;\n  ]);\n&#125;\n根據收到的資料，動態改變表單欄位與設定\n\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular v20 Features","url":"/2025/06/01/Angular-v20-Features/","content":"近年來 Angular 團隊採用以下功能開發的三階段流程，在架構上進行重大變革：\n\nVision （願景）：提出早期概念版本\nPreview （預覽）：收集開發者社群的深入回饋\nStable （穩定版）：根據回饋加以完善，以求最大影響力與穩定性\n\n以下是本次 Angular v20 版本的重要更新：\n吉祥物Angular 標誌性的盾牌符號很強大，不過在過去幾個月裡，團隊與 Dart 、 Flutter 和 Firebase 吉祥物背後的創意團隊合作，激盪出一些令人驚豔的概念。以下為 Angular 官方吉祥物的提案，由左至右分別為：\n\n\n\nAngular shaped character\nAnglerfish\nAnglerfish variation\n\n\n\n\n\n\n\n\n投票 RFC - Angular official mascot #61733\nSignals在 Angular v16 引入響應式的 Signal ，它可以用於管理元件的狀態。\nSignals 家族\n\n\n\nresource API考量到使用 Signal 處理異步任務（那些完成時間無法預測的任務），團隊被引導出新的 resource API ，一個用於宣告異步依賴的新原語（ primitive ）。使用 resource 可以將狀態、值和其他屬性做為 Signal 來存取，無縫地將它們整合到其他基於 Signal 的邏輯和範本中。\n\n實驗性 httpResource以響應式的方式發出 HTTP 請求來獲取資料，它建構在 HttpClient 上，所以支援所有原本的功能，像是攔截器、模擬及測試。它同時還具備 Signal 的響應式能力。\n// products() 會是一個包含 HTTP 回應的 Signal\nconst products = httpResource(\n  () => `/api/product/$&#123;productId()&#125;`\n);\n\n官方 API httpResource\n\n實驗性 resource從 resource 將回應串流回來，對於需要逐步接收回應的場景（如大型語言模型 LLM 的打字機效果）非常有用。\ncharacters = resource(&#123;\n  stream: async () => &#123;\n    const data = signal&lt;ResourceStreamItem&lt;string>>(&#123;\n      value: \"\",\n    &#125;);\n\n    getStreamData(data);\n\n    return data;\n  &#125;,\n&#125;);\n\n至於 Signal API 家族的其他成員，團隊宣布 linkedSignal 、 effect 、 afterNextRender 、 afterRenderEffect 等更多 API 已升級至穩定版，並準備好在生產環境中使用。\n官方指南 Async reactivity with resources\n\nSignal Forms目前團隊正在開發一個新的、基於 Signal 的表單系統進化版，目標是將備受推崇的範本驅動和響應式表單風格的最佳部分，結合成一個統一的表單系統，從最簡單的登入頁面到最複雜的資料表格，都提供卓越的開發者體驗並具備擴展性。一如既往，向後相容性和互通性是團隊的核心考量。\n\n\n\n\n開發者體驗（ DX ）更新\nHost bindingsHost bindings 允許你在元件和指令中將動態值綁定到你的 host 元素，然而那些表達式沒有經過型別檢查，這可能會導致執行期錯誤。在 Angular 第 20 版中，團隊為 host 屬性以及 @HostBinding 和 @HostListener 裝飾器都支援型別檢查。語言服務（ Language Service ）也更新支援如語法高亮（ syntax highlighting ）、跳轉到定義（ go to definition ）以及在 host bindings 內部進行自動化重命名（ automated renaming ）等功能。若想試用這個新功能，在專案設定中啟用 typeCheckHostBindings 為 true 即可。\nimport &#123; Component &#125; from '@angular/core';\n\n@Component(&#123;\n  ...\n  host: &#123;\n    '[style.color]': 'color' // v20 後，若 color 不存在，編譯期會有型別錯誤\n  &#125;\n&#125;)\nexport class AppComponent &#123; &#125;\n\n動態元件建立版本更新前，必須以命令式的方式手動套用 input 變更，這不甚理想。\nage = input(30);\n\nngOnInit() &#123;\n  this.componentRef = this.viewContainerRef.createComponent(ProfileView);\n&#125;\n\nngOnChanges(changes: SimpleChanges) &#123;\n  if (changes.age) &#123;\n    this.componentRef?.setInput('userAge', this.age());\n  &#125;\n&#125;\n\nAngular v20 可以使用新的 API ，在建立時宣告 input 和 output 綁定，並讓框架處理其餘部分。新的 API 讓 inputs 和 outputs 經由與在範本中綁定它們時相同的機制。\ncreateComponent(ProfileView, &#123;\n  bindings: [\n    // 綁定 Signal 到 input\n    inputBinding('userAge', this.age),\n\n    // 綁定到 output\n    outputBinding&lt;Result>('onUserAction', result => console.log(result)),\n  ],\n&#125;);\n\n新的 API 更允許將指令應用於動態建立的元件，例如，將 ActiveUser 指令套用在 UserInfo 元件。\ncreateComponent(ProfileView, &#123;\n  bindings: [...],\n  directives: [\n    ActiveUser,\n  ]\n&#125;);\n\n若需要綁定到指令的 inputs 與 outputs ，只要像在元件中加入綁定一樣，使用相同的新宣告式 API 即可將它們套用至指令。\ncreateComponent(UserInfoComponent, &#123;\n  bindings: [...],\n  directives: [\n    &#123;\n      type: HasColor,\n      bindings: [inputBinding('color', () => 'red')]\n    &#125;\n  ]\n&#125;);\n\n\n官方 API\n\ncreateComponent\ninputBinding\noutputBinding\n\n\n\n其他 DX 更新\n支援 TypeSript 5.8\n支援範本中未標記的範本字串表達式（untagged template literal expressions）\n移除了 Angular Material 對 @angular/animations 的依賴（若未使用動畫）\n預設啟用範本的熱模組替換（HMR）\n新增一個 schematic 用於清理專案中未使用的匯入\n\n\n\n這些改進旨在讓開發過程更流暢、更安全（型別檢查）、更高效，並減少最終應用程式的打包體積。\n效能隨著這個版本中發布的功能， Angular 將效能做為開發者的預設選項，引入基於 Signal 的響應式模型和伺服器端渲染支援等功能，使交付高效能網頁應用程式比以往更容易。伺服器端渲染（ SSR ）幫助 Angular 開發者交付高效能的應用程式。 SSR 允許在伺服器上渲染包含初始頁面狀態的頁面，並將它們傳送到瀏覽器，以實現更快的初始載入和更好的搜尋引擎優化（ SEO ）。\n\n水合（ Hydration ）在 v16 版本中，完整應用程式水合（ full application hydration ）會重複使用伺服器渲染的 DOM 結構，並持久化應用程式狀態，同時傳輸已由伺服器擷取的應用程式資料。如果沒有啟用水合， SSR 應用程式將需要銷毀並重新渲染整個應用程式的 DOM 。增量式水合（ incremental hydration ） 在 v19 版本以開發者預覽的形式登場，其明確目標是幫助開發者交付快速載入的應用程式，因為初始載入對於創造絕佳的終端使用者體驗非常重要。\n憑藉增量式水合的強大功能，開發者可以選擇範本的哪些部分延遲載入和水合，從而減少打包體積和互動時間。增量式水合自 v20 版本起已進入穩定版，這意味著開發者可以放心地享受這個強大新功能帶來的好處。\n\n\n使用步驟：\n\n加入 provideClientHydration 與 withIncrementalHydration 到應用程式設定。bootstrapApplication(App, &#123;\n  providers: [\n    provideClientHydration(withIncrementalHydration())\n  ]\n&#125;);\n使用帶有 hydrate on 、 hydrate when 或 hydrate never 等，精確指定哪些使用者事件應該觸發 Angular 載入和水合延遲載入的內容，這有助於顯著改善首次互動時間（ Time To Interaction, TTI ）。@defer (hydrate on interaction) &#123;\n  &lt;large-component />\n&#125; @placeholder &#123;\n  &lt;div>Larget component placeholder&lt;/div>\n&#125;\n\n\n官方指南 Incremental Hydration\n\n\n路由級別渲染模式（ Route-Level Render Mode ）設定 APIAngular 的路由級別渲染模式設定 API 在 v20 版本中提升至穩定版，讓開發者完整控制應用程式的渲染，例如明確地定義每個路由元件要由伺服器渲染（ SSR ）、靜態生成（ SSG ）或客戶端渲染（ CSR ）。\n&#123;\n  path: 'profile',\n  renderMode: RenderMode.Server,\n&#125;,\n&#123;\n  path: 'about',\n  renderMode: RenderMode.Prerender,\n&#125;,\n\nZoneless在 v20 版本中， Zoneless Angular 由實驗階段進入開發者預覽階段。採用 Zoneless Angular 可以透過消除不必要的變更偵測循環來提高應用程式效能。由於 zone.js 用來修補瀏覽器 API ，它通知 Angular 執行變更偵測來響應任何瀏覽器事件，進而更新應用程式的範本，但也導致許多不必要的檢查。因此 Zoneless 的目標是移除 zone.js ，並結合 Signals 來明確控制何時與如何觸發變更偵測。\nSignals + Zoneless 的優勢：\n\n提升效能\n改善除錯體驗\n更好的生態系相容性\n更小的 JavaScript 負載\n\n啟用 Zoneless 步驟：\n\n升級到 Angular v20 （ ng update ）\n在應用程式設定中加入 provideZonelessChangeDetection\n反安裝 ZoneJS （ npm uninstall zone.js ）\n\n\n官方指南 Angular without ZoneJS (Zoneless)\n\n\nChrome 開發者工具的 Angular 自訂追蹤由 Angular 團隊與 Chrome DevTools 團隊合作開發，在 Chrome 開發者工具加入 Angular 自訂追蹤（ custom track ），使用新 Angular 追蹤的步驟：\n\n升級到 Angular v20 （ ng update ）\n升級到 Chrome v136 或更高版本\n在 Chrome 主控台執行 ng.enableProfiling() 來啟用效能數據收集\n\n在 Chrome DevTools 的 Performance 面板中，會出現一個名為 “Angular” 的自訂軌道，顯示 Angular 特有的效能數據，如變更偵測、元件生命週期等，幫助開發者更容易區分應用程式碼和函式庫程式碼的效能瓶頸。\n\n\n工具鏈與基礎設施\n測試隨著 Karma 被棄用， Angular 團隊一直專注於尋找合適的測試替代方案，以滿足三個目標：\n\n提供清晰的遷移路徑\n擁有強大的社群支援\n改善開發者體驗\n\n目前提供的實驗性支援：\n\nJest （用於 Node 環境測試）\nWeb Test Runner （用於瀏覽器環境測試）\nVitest （ Angular v20 新增的實驗性支援，可同時用於 Node 和瀏覽器環境）\n\n最終只會選擇一種方案進入穩定版，社群的回饋將是重要參考。\n\n工具鏈更新\nAngular DevTools 的路由視覺化（ Router Visualization ）實驗性支援，啟動方式如下：\n\n\n\n完成後，即可看到執行期的視覺化路由。\n\n\n\nWebpack 已從 ng new 移除，意味著簡化建置系統和依賴項，這使得新建立的 Angular 專案的依賴項減少了約 40% 。\n\n\n生成內容安全策略（ Auto Content Security Policy, AutoCSP ）Angular 團隊與 Google 安全工程團隊合作，加入在生產建置中使用 AutoCSP 的支援，在 Angular v19 中初步實現，而在 v20 中修復錯誤並使其更加穩定。\n啟用 AutoCSP 的方式：在 angular.json 的 architect.build.options.security 中加入 &quot;autoCsp&quot;: true\n啟用後，在生產建置時會自動生成內容安全策略，並包含在應用程式碼中，有助於防禦跨網站指令碼（ cross-site scripting, XSS ）攻擊。如果惡意行為者將內嵌腳本注入應用程式，自動化的 CSP 設定將阻止該腳本執行。\n工具鏈的簡化和安全性的增強，旨在讓開發者更專注於業務邏輯，同時建構出更安全、更輕量的應用程式。\n\n\nAI 整合Build with AI 為 AI 與 Angular 的新家，這個新的資源中心旨在幫助 Angular 開發者充分使用 AI ，其內容包含：\n\n指引與最佳實踐\n入門專案\n程式碼配方\n引導式教學\n\n網站提供 Google 的 AI 工具整合，如 Vertex AI 、 Firebase 與 Genkit ，這些知識和模式也適用於其他 AI 解決方案。\n總結Angular v20 是一個重要的里程碑，帶來了多方面的提升，包括更成熟的 Signal API 、顯著的效能改進（如增量式水合和 Zoneless 的進展）、更強大的開發者工具（如新的 Chrome DevTools 整合和測試方案），以及對 AI 整合的積極佈局。核心目標始終是讓開發者能夠更輕鬆、更高效地打造出使用者喜愛的高品質應用程式。\n參考連結官方 YouTube 影片 Angular v20 Developer Event 2025\n","categories":["Angular"],"tags":["Angular","Web"]},{"title":"Angular Signals 演進說明","url":"/2025/08/31/Angular-Signals-Introduction/","content":"Angular Signals 是 Angular 框架在開發過程中一項重要的演進，旨在為應用程式的狀態管理提供更優雅、更高效的解決方案。以下是 Signals 在 Angular 各主要版本從提案到正式發佈的演進：\n\n\n\n年.月\n版本\n演進說明\n\n\n\n2022.06\n&nbsp;&nbsp;v14&nbsp;&nbsp;\nRFC (Request for Comments) 提案階段目標是找出能解決 Angular 變更偵測（change detection）痛點的新方案，能夠與 RxJS 等現有工具鏈整合，並減少對 ZoneJS 函式庫的依賴。\n\n\n2022.11\n&nbsp;&nbsp;v15&nbsp;&nbsp;\n實驗性階段Angular 內部透過 createSignal() 函數來建立 Signal ，此階段不推薦用於生產環境。參考連結：Angular v15 is now available!\n\n\n2023.05\n&nbsp;&nbsp;v16&nbsp;&nbsp;\nSignals 革命性發展的里程碑Signals 被正式發布，不再是實驗性功能，意謂 Signals 已經足夠穩定和成熟，可以安全地在生產環境中使用。引入幾個關鍵的 Signals 相關 APIs：1. signal()：用於創建一個 writable Signal ，使用 .set() 來賦值2. computed()：創建一個依賴於其他 Signals ，並且會自動更新的唯讀 Signal （亦即，不可使用 .set() 來賦值）3. effect()：用於在 Signal 的值改變時觸發副作用（side effects），例如更新 DOM 或觸發 API 呼叫在 Observable 與 Signal 之間進行轉換：Signal -&gt; Observable：import &#123; toObservable &#125; from &#39;@angular/core/rxjs-interop&#39;;Observable -&gt; Signal：import &#123; toSignal &#125; from &#39;@angular/core/rxjs-interop&#39;;參考連結：Angular v16 is here!\n\n\n2023.11\n&nbsp;&nbsp;v17&nbsp;&nbsp;\n深度整合新功能，成為新功能的核心這個版本中最重要的相關更新是 Signals 引入 @if 、 @for 、 @switch 等內建控制流語法。這些新的語法在內部完全依賴 Signals 進行變更偵測，大大簡化了模板的變更偵測機制，並且不需要依賴 zone.js 也能正常運作，這對於未來實現 Zoneless 的應用程式非常有幫助。參考連結：Introducing Angular v17\n\n\n2024.05\n&nbsp;&nbsp;v18&nbsp;&nbsp;\n雙向繫結與新 API引入幾個重要的 Signals 相關 APIs ，簡化元件間的資料傳遞：1. input() 讓父元件可以傳遞一個 Signal 的值給子元件2. output() 讓子元件可以發出事件，並在父元件中以 Signal 的方式訂閱這些事件3. model()：結合了 @Input() 和 @Output() 的功能，讓開發者可以用更簡潔的方式實現雙向資料繫結。參考連結：Angular v18 is now available!\n\n\n2024.11\n&nbsp;&nbsp;v19&nbsp;&nbsp;\n反應式原語（Reactivity Primitives）引入新的 Signals 實驗性 APIs 以取得開發者回饋：1. linkedSignal()：創建一個類似於 computed() ，而且可以依賴於其他狀態的 writable Signal2. resource()：執行非同步操作來取得資源參考連結：Meet Angular v19\n\n\n2025.05\n&nbsp;&nbsp;v20&nbsp;&nbsp;\n穩定階段引入新的 Signals 實驗性 API：httpResource() 使用 HttpClient 取得 HTTP 資源並回傳 HttpResourceRef ，其內容包含 value 屬性的 Signal ，可直接在範本中使用參考連結：Announcing Angular v20\n\n\n官網介紹：\n\nAngular Signals\n\n","categories":["Angular","Signal"],"tags":["Angular","Web","Signal"]},{"title":"NVM 簡介","url":"/2025/09/07/NVM-Introduction/","content":"在網頁開發中， Node.js 已成為不可或缺的工具。然而，專案之間常常需要不同版本的 Node.js ，例如舊專案需要 14.x ，新專案則可能使用 20.x 。此時，使用 NVM (Node Version Manager) 來管理多版本 Node.js 就變得非常重要。\n什麼是 NVM ？NVM 是一個命令列工具，可在主機上安裝多個版本的 Node.js ，解決不同專案間快速切換 Node.js 版本，同時避免全域安裝 Node.js 帶來的相容性問題。\n於 Windows 下安裝 NVM由於 Windows 沒有官方的 NVM ，因此特別介紹使用 nvm-windows 來進行安裝。\n\n由 nvm-windows 下載安裝檔 nvm-setup.exe（建議安裝 1.1.12 版本較穩定）。\n\n執行安裝程式並設定安裝目錄。\n\n\n\n若曾經安裝過 Node.js ，需要先完整移除  \n\n  2.1 NVM 安裝路徑  \n  2.2 Node.js 設定路徑  \n\n安裝完成後，開啟 PowerShell 檢查版本：  nvm --version\n\nNVM 常用指令\nnvm install &lt;version&gt; 安裝指定版本的 Node.js，例如 nvm install 18.20.2\nnvm install latest 安裝最新的 LTS（長期支援）版本\nnvm uninstall &lt;version&gt; 移除某個版本的 Node.js\nnvm use &lt;version&gt; 切換至指定版本，例如 nvm use 18\nnvm current 查看目前使用的 Node.js 版本\nnvm list 或 nvm ls 列出已安裝的 Node.js 版本\n\n使用情境使用管理員身份開啟 PowerShell\n\n\n\n安裝指定版本的 Node.js  1.1 以 nvm list 確認目前已安裝的版本\n  \n  1.2 安裝 Node.js 18.20.2\n  \n  1.3 以 nvm list 確認已安裝該版本的 Node.js\n  \n  1.4 以 nvm use 切換至該 Node.js 18.20.2 版本\n  \n  1.5 以 node -v 或 nvm current 檢查 Node.js 版本\n  \n\n安裝最新 LTS 版本的 Node.js 並切換至該版本  2.1 以 nvm install latest 安裝最新 LTS 版本\n  \n  2.2 以 nvm list 確認已安裝該版本的 Node.js （* 代表目前使用的版本）\n  \n  2.3 以 nvm use 切換至該 Node.js 24 主版本\n  \n  2.4 以 nvm list 及 nvm current 確認已切換至指定版本\n  \n\n\n由檔案結構可以發現，使用 nvm install &lt;version&gt; 安裝的 Node.js 版本都會存在 NVM 資料夾中，並且設定軟連結（symbolic link）到 Node.js 的執行路徑，藉由＂捷徑＂快速切換 Node.js 版本。  \n\n","tags":["Web"]},{"title":"Angular CLI MCP 介紹","url":"/2025/09/13/Angular-CLI-MCP/","content":"在 Angular CLI 20.1.0 加入了 MCP 伺服器，協助開發者基於 Angular 提供的官方 API 進行快速、可靠、準確地建立應用程式各項功能，也確保生成的程式碼會同步 Angular 官方最新的最佳實踐。\n\n\nModel Context Protocol (MCP)想像有一個 AI 模型，它要跟外部世界（例如資料庫、 API 、檔案系統、甚至公司內部系統）互動，但不同系統的介面和規則都不一樣。如果要讓 AI 模型連接不同的工具或資料來源，開發者常常需要寫一堆客製化程式，像是自己設計 API 、格式轉換、錯誤處理等等，耗時且不易共享。\nMCP 的出現，解決了上述問題，因為 MCP 像一個結合翻譯官與溝通規範的媒介，讓 AI 模型與各種不同來源的資料或工具，用統一的方式來交談。\n它具備以下好處：\n\n降低整合難度：只要大家都用 MCP ，模型就能更輕鬆地接取不同工具。\n可移植性：一個 MCP 工具可以同時使用在不同的 AI 模型或平台，減少重工。\n安全性：MCP 定義了更明確的存取規範，避免 AI 模型隨便存取敏感資料。\n\n如何在 Angular 使用 MCP ？\n首先建立一個 Angular 20.1.0 版本（或以上）的專案，以專案名稱 angular-cli-mcp 為例：npx @angular/cli@20.1.0 new angular-cli-mcp\n\n使用以下指令來啟動 MCP 伺服器，執行結束會有指引說明如何設定本機環境：ng mcp\n\n\n在專案根目錄建立 .vscode/mcp.json 檔案（以 VS Code 為例），並加入以下設定：\n&#123;\n  &quot;servers&quot;: &#123;\n    &quot;angular-cli&quot;: &#123;\n      &quot;command&quot;: &quot;npx&quot;,\n      &quot;args&quot;: [&quot;-y&quot;, &quot;@angular&#x2F;cli&quot;, &quot;mcp&quot;]\n    &#125;\n  &#125;\n&#125;\n目前提供兩個選項，可加入至 args 參數：\n\n--read-only 僅註冊不會對專案進行改動的工具。編輯器或程式碼代理（ agent ）仍可能執行編輯。預設為 false 。\n--local-only 僅註冊不需要網路連線的工具。編輯器或程式碼代理仍可能透過網路傳送資料。預設為 false 。\n\n\n啟動 MCP 伺服器的方式（以下二擇一）\n\n在 mcp.json 檔案中可看到在 angular-cli MCP 伺服器加入後出現的選項：\n點選＂開始＂後即可啟動 MCP 伺服器：\n在延伸模組中的 MCP 伺服器選取 angular-cli 後，手動啟動伺服器：\n\n\n在 agent 模式下，以 prompt 進行設定檢查：\n\n目前 MCP 伺服器提供三個工具：\n\nsearch_documentation 搜尋在 https://angular.dev 的 Angular 官方文件，提供 API 使用說明與開發範例等（下圖僅擷取部分回應內容）。\nlist_projects 列出 angular.json 檔案內所定義的應用程式（ applications ）和函式庫（ libraries ）。\nget_best_practices 使用 #angular-cli 提供 Angular 官方完整的最佳實踐指南（下圖僅擷取部分回應內容）。\n\n\n\n\n\n使用範例\n在某個資料夾下建立服務，以取得後端 API 資料\n\n資料夾為 posts服務名稱為 post後端 URL 為 https://jsonplaceholder.typicode.com/posts\n\n 在送出 prompt 後，我們可以經由以下的 response 檢查它的思考邏輯是否正確：\n\n建立資料夾 posts 與服務 post \n由於需要取得後端 API 資料，需要提供 HttpClient \n參考 Angular 官方命名規則，修改服務名稱為 post.service.ts \n顯示 post.service.ts 實作內容 \n\n\n在 posts 資料夾內建立元件，以顯示取得的後端資料\n\n資料夾為 posts元件名稱為 posts.component.ts\n\n 在送出 prompt 後，我們可以經由以下的 response 檢查它的思考邏輯是否正確：\n\n任務拆解，並建立 posts 元件 \n設定並更新路由 \n在調整路由的過程中，會持續檢查錯誤並修正 \n在元件注入服務，並修正錯誤 \n更新 posts.component.html 內容，以顯示後端資料 \n清理 app.component.html 內容，將路由導到 posts 元件 \n\n\n\n程式碼\nGitHub repo\n\n參考來源\n官方文件 Angular CLI MCP Server setup\n\n","categories":["Angular","AI","MCP"],"tags":["Angular","Web","AI","MCP"]},{"title":"替 Angular 提供客製化的 Copilot 指令","url":"/2025/09/20/Copilot-instructions-for-Angular/","content":"大型語言模型（ large language model, LLM ）已成為近年來開發者投入研究的議題，它已在基礎上改變了＂軟體如何開發＂與＂開發者如何工作＂這兩件事。雖然 LLM 能夠產生程式碼，但為了 Angular 等不斷發展的框架產生程式碼就可能是一個挑戰。指令（ instruction ）和提示（ prompt ）是一種新興的標準，用於生成支援具有特定領域細節的現代程式碼。\n以下指令是用來幫助 LLM 根據 Angular 最佳實踐（由此複製 ）生成符合規範的程式碼：\nYou are an expert in TypeScript, Angular, and scalable web application development. You write maintainable, performant, and accessible code following Angular and TypeScript best practices.\n## TypeScript Best Practices\n- Use strict type checking\n- Prefer type inference when the type is obvious\n- Avoid the `any` type; use `unknown` when type is uncertain\n## Angular Best Practices\n- Always use standalone components over NgModules\n- Must NOT set `standalone: true` inside Angular decorators. It's the default.\n- Use signals for state management\n- Implement lazy loading for feature routes\n- Do NOT use the `@HostBinding` and `@HostListener` decorators. Put host bindings inside the `host` object of the `@Component` or `@Directive` decorator instead\n- Use `NgOptimizedImage` for all static images.\n  - `NgOptimizedImage` does not work for inline base64 images.\n## Components\n- Keep components small and focused on a single responsibility\n- Use `input()` and `output()` functions instead of decorators\n- Use `computed()` for derived state\n- Set `changeDetection: ChangeDetectionStrategy.OnPush` in `@Component` decorator\n- Prefer inline templates for small components\n- Prefer Reactive forms instead of Template-driven ones\n- Do NOT use `ngClass`, use `class` bindings instead\n- DO NOT use `ngStyle`, use `style` bindings instead\n## State Management\n- Use signals for local component state\n- Use `computed()` for derived state\n- Keep state transformations pure and predictable\n- Do NOT use `mutate` on signals, use `update` or `set` instead\n## Templates\n- Keep templates simple and avoid complex logic\n- Use native control flow (`@if`, `@for`, `@switch`) instead of `*ngIf`, `*ngFor`, `*ngSwitch`\n- Use the async pipe to handle observables\n## Services\n- Design services around a single responsibility\n- Use the `providedIn: 'root'` option for singleton services\n- Use the `inject()` function instead of constructor injection\n\nCopilot 指令介紹指令是幫助我們客製化與 LLM 的對話，來配合滿足程式碼的最佳實踐與專案需求。經由撰寫一致配置檔，可以自動將我們偏好的上下文（ context ）、工具和指南套用至每一次的對話，以節省時間並確保回應的一致性，而不需要在每個聊天請求中，手動提供相同的資訊。以 VS Code 為例，有五種主要的方法客製化對話，這些選項可以單獨存在或彼此結合。本篇僅介紹客製化指令的使用方式。\n\n\n\n項目\n說明\n適用情境\n優缺點\n\n\n\nCustom instructions客製化指令\n使用 Markdown 檔案定義在程式碼生成、程式碼審查、訊息提交等常見任務時的規範或指南\n- 想在每次對話都自動套用程式碼風格、訊息提交的格式、專案內部的程式碼審查標準等- 在大型團隊、專案規模大、多人合作的時候特別適用\n👍 針對專案設定 glob pattern （例如只針對某些檔案類型或資料夾），達到一致性👎 初期要耗時寫規範👎 如果規範太多或太嚴格，可能造成 AI 回應速度過慢或回應被限制而不夠靈活\n\n\nPrompt files提示檔案\n使用 Markdown 檔案定義可重複使用的（ reusable ）的提示（ prompt ）來處理常見或重複的開發任務\n- 利用共享提示，讓大家對某些任務的預期結果一致- 有許多重複性工作或標準化流程時，例如專案中常常要搭建新元件、寫某種格式的文件、生成測試案例等任務\n👍 可複用，節省時間，且容易維護重複任務的品質一致性👎 初期要耗時設計模板👎 若提示定義不夠清楚或文件沒維護好，可能導致輸出結果不穩定\n\n\nChat modes聊天模式\n使用 Markdown 檔案建立特定角色或任務助理，例如資料庫管理、前端開發、規劃研究等，在這個模式可以定義範疇與能力、哪一些工具可以被存取、首選的語言模型等\n針對專案不同階段（設計階段、測試階段、維護階段）切換不同風格與需求，或者以不同人員（前端、後端、安全審查等）進行此模式，預期 AI 會有不同的回應偏好和工具權限\n👍 能夠更精細控制 AI 在不同情境中的行為與工具使用，提高專業任務中的效率與精準度👎 設定的複雜度較高，需要維護多個模式與文件。若模式切換頻繁，在管理上較麻煩\n\n\nLanguage models語言模型選擇\n在不同任務間切換模型，選擇最適合的模型來處理特定需求（例如：開發速度快，但能力中等或者進行複雜推理與視覺處理等），允許自帶 API key 存取不同模型或在本地佈署模型\n- 當任務強度、性能或需求精確度不一樣時很有用（例如：簡單重構時希望響應快，而進行架構設計或安全審查時希望使用更強大的模型）- 適合有成本考量或想控制資源時使用\n👍 靈活根據任務調整模型，以節省時間或資源；若有客製化模型或引入雲端模型，更具拓展的可能性👎 模型間切換可能導致風格、輸出一致性有差異👎 較好的模型通常成本較高，而本地部署或 API key 的管理需注意安全性與版本控制\n\n\nModel Context Protocol (MCP) 與工具整合\n使用 MCP 連接外部服務或專用工具，讓對話不只在程式碼內部操作，也能查詢資料庫、呼叫 API 、取得即時資訊或執行其它開發工具\n當專案需要外部資源或工具整合，例如進行跨工具或跨領域的任務時非常有用\n👍 能整合更多上下文與資源，提高回應的實用性與全面性👍 把 workflow 串起來，不用跳出 VS Code👎 安全與權限需注意（例如存取外部服務憑證與 API key 等）👎 工具整合、維護成本高，可能有相依性或工具不穩定問題\n\n\n\n\n如何使用客製化指令？VS Code 可支援多個基於 Markdown 的指令文件，並會將其組合在一起加入至對話上下文中。指令檔的用途並不是讓 VS Code 自動生成 Angular 程式碼，而是讓編輯器具備 AI 輔助功能，因此需要搭配 VS Code 的延伸模組 GitHub Copilot 與 GitHub Copilot Chat 來使用。準備指令文件的方式主要有以下兩種：\n\n單個 .github/copilot-instructions.md 檔\n\n確保啟用 github.copilot.chat.codeGeneration.useInstructionFiles 設定\n在工作區的根目錄建立 .github/copilot-instructions.md 檔，並撰寫客製化的指令。 VS Code 會自動將指令內容套用到工作區的對話需求中\n\n\n一或多個 .instructions.md 檔（可針對不同的程式語言或框架，準備不同的指令文件），它們只會在建立與修改檔案時使用，以 Angular 框架開發為例：\n\n準備一個 Angular 提供的指令內容寫入 .instructions.md\t並置於專案根目錄下\n若有多個指令資料夾，可以在工作區的 chat.instructionsFilesLocations 進行設定\n\n\n使用上有兩種方式：\n\n\n將 applyTo 屬性加到檔案標頭，指定哪些檔案需要套用指令。\n手動將指令檔附加到對話提示中\n檔名可以更名為 Angular.instructions.md 以方便在選取時進行辨認\n\n\n\n\n\n使用範例\n在某個資料夾下建立服務，以取得後端 API 資料\n資料夾為 posts服務名稱為 post後端 URL 為 https://jsonplaceholder.typicode.com/posts\n\n 在送出 prompt 後，我們可以經由以下的 response 檢查它的思考邏輯是否正確：\n建立資料夾 posts 與服務 post.service.ts \n分析服務 post.service.ts 需要的模組與介面，由 LLM 的思維過程中可以看到其遵照指令的規範來生成程式碼 \n加入 provideHttpClient() 讓服務 post.service.ts 能使用 HttpClient 取得後端 API 資料 \n修改 app.ts 來顯示後端資料 \n整理變更摘要 \n\n\n\n總結使用指令雖然可以幫助我們產生符合規範的程式碼，但是在技術快速更迭的時代，這些依據過時規範而產出的程式碼或 APIs 可能會不敷使用，甚至開發者需要花更多時間來除錯或重構某些很簡單的問題。若想要生成符合最新規範的程式碼，可以選擇使用 MCP (Model Context Protocol) 的方式來進行，細節可參考 Angular CLI MCP 介紹。\n程式碼\nGitHub repo\n\n參考來源\n官方文件 LLM prompts and AI IDE setup\n\n","categories":["Angular","AI","LLM"],"tags":["Angular","Web","AI","LLM"]}]